{"ast":null,"code":"'use strict';\n\n/**\n * Constants.\n */\nvar errorMessage;\nerrorMessage = 'An argument without append, prepend, ' + 'or detach methods was given to `List';\n\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List( /*items...*/\n) {\n  if (arguments.length) {\n    return List.from(arguments);\n  }\n}\nvar ListPrototype;\nListPrototype = List.prototype;\n\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function /*items...*/\n() {\n  return List.from.call(this, arguments);\n};\n\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\nList.from = function (items) {\n  var list = new this(),\n    length,\n    iterator,\n    item;\n  if (items && (length = items.length)) {\n    iterator = -1;\n    while (++iterator < length) {\n      item = items[iterator];\n      if (item !== null && item !== undefined) {\n        list.append(item);\n      }\n    }\n  }\n  return list;\n};\n\n/**\n * List#head\n * Default to `null`.\n */\nListPrototype.head = null;\n\n/**\n * List#tail\n * Default to `null`.\n */\nListPrototype.tail = null;\n\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\nListPrototype.toArray = function () {\n  var item = this.head,\n    result = [];\n  while (item) {\n    result.push(item);\n    item = item.next;\n  }\n  return result;\n};\n\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\nListPrototype.prepend = function (item) {\n  if (!item) {\n    return false;\n  }\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#prepend`.');\n  }\n  var self, head;\n\n  // Cache self.\n  self = this;\n\n  // If self has a first item, defer prepend to the first items prepend\n  // method, and return the result.\n  head = self.head;\n  if (head) {\n    return head.prepend(item);\n  }\n\n  // ...otherwise, there is no `head` (or `tail`) item yet.\n\n  // Detach the prependee.\n  item.detach();\n\n  // Set the prependees parent list to reference self.\n  item.list = self;\n\n  // Set self's first item to the prependee, and return the item.\n  self.head = item;\n  return item;\n};\n\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\nListPrototype.append = function (item) {\n  if (!item) {\n    return false;\n  }\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#append`.');\n  }\n  var self, head, tail;\n\n  // Cache self.\n  self = this;\n\n  // If self has a last item, defer appending to the last items append\n  // method, and return the result.\n  tail = self.tail;\n  if (tail) {\n    return tail.append(item);\n  }\n\n  // If self has a first item, defer appending to the first items append\n  // method, and return the result.\n  head = self.head;\n  if (head) {\n    return head.append(item);\n  }\n\n  // ...otherwise, there is no `tail` or `head` item yet.\n\n  // Detach the appendee.\n  item.detach();\n\n  // Set the appendees parent list to reference self.\n  item.list = self;\n\n  // Set self's first item to the appendee, and return the item.\n  self.head = item;\n  return item;\n};\n\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\nfunction ListItem() {}\nList.Item = ListItem;\nvar ListItemPrototype = ListItem.prototype;\nListItemPrototype.next = null;\nListItemPrototype.prev = null;\nListItemPrototype.list = null;\n\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\nListItemPrototype.detach = function () {\n  // Cache self, the parent list, and the previous and next items.\n  var self = this,\n    list = self.list,\n    prev = self.prev,\n    next = self.next;\n\n  // If the item is already detached, return self.\n  if (!list) {\n    return self;\n  }\n\n  // If self is the last item in the parent list, link the lists last item\n  // to the previous item.\n  if (list.tail === self) {\n    list.tail = prev;\n  }\n\n  // If self is the first item in the parent list, link the lists first item\n  // to the next item.\n  if (list.head === self) {\n    list.head = next;\n  }\n\n  // If both the last and first items in the parent list are the same,\n  // remove the link to the last item.\n  if (list.tail === list.head) {\n    list.tail = null;\n  }\n\n  // If a previous item exists, link its next item to selfs next item.\n  if (prev) {\n    prev.next = next;\n  }\n\n  // If a next item exists, link its previous item to selfs previous item.\n  if (next) {\n    next.prev = prev;\n  }\n\n  // Remove links from self to both the next and previous items, and to the\n  // parent list.\n  self.prev = self.next = self.list = null;\n\n  // Return self.\n  return self;\n};\n\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.prepend = function (item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#prepend`.');\n  }\n\n  // Cache self, the parent list, and the previous item.\n  var self = this,\n    list = self.list,\n    prev = self.prev;\n\n  // If self is detached, return false.\n  if (!list) {\n    return false;\n  }\n\n  // Detach the prependee.\n  item.detach();\n\n  // If self has a previous item...\n  if (prev) {\n    // ...link the prependees previous item, to selfs previous item.\n    item.prev = prev;\n\n    // ...link the previous items next item, to self.\n    prev.next = item;\n  }\n\n  // Set the prependees next item to self.\n  item.next = self;\n\n  // Set the prependees parent list to selfs parent list.\n  item.list = list;\n\n  // Set the previous item of self to the prependee.\n  self.prev = item;\n\n  // If self is the first item in the parent list, link the lists first item\n  // to the prependee.\n  if (self === list.head) {\n    list.head = item;\n  }\n\n  // If the the parent list has no last item, link the lists last item to\n  // self.\n  if (!list.tail) {\n    list.tail = self;\n  }\n\n  // Return the prependee.\n  return item;\n};\n\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.append = function (item) {\n  // If item is falsey, return false.\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#append`.');\n  }\n\n  // Cache self, the parent list, and the next item.\n  var self = this,\n    list = self.list,\n    next = self.next;\n\n  // If self is detached, return false.\n  if (!list) {\n    return false;\n  }\n\n  // Detach the appendee.\n  item.detach();\n\n  // If self has a next item...\n  if (next) {\n    // ...link the appendees next item, to selfs next item.\n    item.next = next;\n\n    // ...link the next items previous item, to the appendee.\n    next.prev = item;\n  }\n\n  // Set the appendees previous item to self.\n  item.prev = self;\n\n  // Set the appendees parent list to selfs parent list.\n  item.list = list;\n\n  // Set the next item of self to the appendee.\n  self.next = item;\n\n  // If the the parent list has no last item or if self is the parent lists\n  // last item, link the lists last item to the appendee.\n  if (self === list.tail || !list.tail) {\n    list.tail = item;\n  }\n\n  // Return the appendee.\n  return item;\n};\n\n/**\n * Expose `List`.\n */\n\nmodule.exports = List;","map":{"version":3,"names":["errorMessage","List","arguments","length","from","ListPrototype","prototype","of","call","items","list","iterator","item","undefined","append","head","tail","toArray","result","push","next","prepend","detach","Error","self","ListItem","Item","ListItemPrototype","prev","module","exports"],"sources":["C:/Users/123/OneDrive/Desktop/git practice/git_destop/git-Check/testing/node_modules/linked-list/_source/linked-list.js"],"sourcesContent":["'use strict';\n\n/**\n * Constants.\n */\n\nvar errorMessage;\n\nerrorMessage = 'An argument without append, prepend, ' +\n    'or detach methods was given to `List';\n\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List(/*items...*/) {\n    if (arguments.length) {\n        return List.from(arguments);\n    }\n}\n\nvar ListPrototype;\n\nListPrototype = List.prototype;\n\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function (/*items...*/) {\n    return List.from.call(this, arguments);\n};\n\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\nList.from = function (items) {\n    var list = new this(), length, iterator, item;\n\n    if (items && (length = items.length)) {\n        iterator = -1;\n\n        while (++iterator < length) {\n            item = items[iterator];\n\n            if (item !== null && item !== undefined) {\n                list.append(item);\n            }\n        }\n    }\n\n    return list;\n};\n\n/**\n * List#head\n * Default to `null`.\n */\nListPrototype.head = null;\n\n/**\n * List#tail\n * Default to `null`.\n */\nListPrototype.tail = null;\n\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\nListPrototype.toArray = function () {\n    var item = this.head,\n        result = [];\n\n    while (item) {\n        result.push(item);\n        item = item.next;\n    }\n\n    return result;\n};\n\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\nListPrototype.prepend = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#prepend`.');\n    }\n\n    var self, head;\n\n    // Cache self.\n    self = this;\n\n    // If self has a first item, defer prepend to the first items prepend\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.prepend(item);\n    }\n\n    // ...otherwise, there is no `head` (or `tail`) item yet.\n\n    // Detach the prependee.\n    item.detach();\n\n    // Set the prependees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the prependee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\nListPrototype.append = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#append`.');\n    }\n\n    var self, head, tail;\n\n    // Cache self.\n    self = this;\n\n    // If self has a last item, defer appending to the last items append\n    // method, and return the result.\n    tail = self.tail;\n\n    if (tail) {\n        return tail.append(item);\n    }\n\n    // If self has a first item, defer appending to the first items append\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.append(item);\n    }\n\n    // ...otherwise, there is no `tail` or `head` item yet.\n\n    // Detach the appendee.\n    item.detach();\n\n    // Set the appendees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the appendee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\nfunction ListItem() {}\n\nList.Item = ListItem;\n\nvar ListItemPrototype = ListItem.prototype;\n\nListItemPrototype.next = null;\n\nListItemPrototype.prev = null;\n\nListItemPrototype.list = null;\n\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\nListItemPrototype.detach = function () {\n    // Cache self, the parent list, and the previous and next items.\n    var self = this,\n        list = self.list,\n        prev = self.prev,\n        next = self.next;\n\n    // If the item is already detached, return self.\n    if (!list) {\n        return self;\n    }\n\n    // If self is the last item in the parent list, link the lists last item\n    // to the previous item.\n    if (list.tail === self) {\n        list.tail = prev;\n    }\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the next item.\n    if (list.head === self) {\n        list.head = next;\n    }\n\n    // If both the last and first items in the parent list are the same,\n    // remove the link to the last item.\n    if (list.tail === list.head) {\n        list.tail = null;\n    }\n\n    // If a previous item exists, link its next item to selfs next item.\n    if (prev) {\n        prev.next = next;\n    }\n\n    // If a next item exists, link its previous item to selfs previous item.\n    if (next) {\n        next.prev = prev;\n    }\n\n    // Remove links from self to both the next and previous items, and to the\n    // parent list.\n    self.prev = self.next = self.list = null;\n\n    // Return self.\n    return self;\n};\n\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.prepend = function (item) {\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#prepend`.');\n    }\n\n    // Cache self, the parent list, and the previous item.\n    var self = this,\n        list = self.list,\n        prev = self.prev;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the prependee.\n    item.detach();\n\n    // If self has a previous item...\n    if (prev) {\n        // ...link the prependees previous item, to selfs previous item.\n        item.prev = prev;\n\n        // ...link the previous items next item, to self.\n        prev.next = item;\n    }\n\n    // Set the prependees next item to self.\n    item.next = self;\n\n    // Set the prependees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the previous item of self to the prependee.\n    self.prev = item;\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the prependee.\n    if (self === list.head) {\n        list.head = item;\n    }\n\n    // If the the parent list has no last item, link the lists last item to\n    // self.\n    if (!list.tail) {\n        list.tail = self;\n    }\n\n    // Return the prependee.\n    return item;\n};\n\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.append = function (item) {\n    // If item is falsey, return false.\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#append`.');\n    }\n\n    // Cache self, the parent list, and the next item.\n    var self = this,\n        list = self.list,\n        next = self.next;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the appendee.\n    item.detach();\n\n    // If self has a next item...\n    if (next) {\n        // ...link the appendees next item, to selfs next item.\n        item.next = next;\n\n        // ...link the next items previous item, to the appendee.\n        next.prev = item;\n    }\n\n    // Set the appendees previous item to self.\n    item.prev = self;\n\n    // Set the appendees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the next item of self to the appendee.\n    self.next = item;\n\n    // If the the parent list has no last item or if self is the parent lists\n    // last item, link the lists last item to the appendee.\n    if (self === list.tail || !list.tail) {\n        list.tail = item;\n    }\n\n    // Return the appendee.\n    return item;\n};\n\n/**\n * Expose `List`.\n */\n\nmodule.exports = List;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}