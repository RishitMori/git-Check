{"ast":null,"code":"// Based on https://github.com/dscape/cycle/blob/master/cycle.js\n\nmodule.exports = function decycle(object) {\n  // Make a deep copy of an object or array, assuring that there is at most\n  // one instance of each object or array in the resulting structure. The\n  // duplicate references (which might be forming cycles) are replaced with\n  // an object of the form\n  //      {$ref: PATH}\n  // where the PATH is a JSONPath string that locates the first occurance.\n  // So,\n  //      var a = [];\n  //      a[0] = a;\n  //      return JSON.stringify(JSON.decycle(a));\n  // produces the string '[{\"$ref\":\"$\"}]'.\n\n  // JSONPath is used to locate the unique object. $ indicates the top level of\n  // the object or array. [NUMBER] or [STRING] indicates a child member or\n  // property.\n\n  var objects = [],\n    // Keep a reference to each unique object or array\n    paths = []; // Keep the path to each unique object or array\n\n  return function derez(value, path) {\n    // The derez recurses through the object, producing the deep copy.\n\n    var i,\n      // The loop counter\n      name,\n      // Property name\n      nu; // The new object or array\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === value) {\n          return {\n            $ref: paths[i]\n          };\n        }\n      }\n\n      // Otherwise, accumulate the unique value and its path.\n\n      objects.push(value);\n      paths.push(path);\n\n      // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        nu = [];\n        for (i = 0; i < value.length; i += 1) {\n          nu[i] = derez(value[i], path + '[' + i + ']');\n        }\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {};\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n          }\n        }\n      }\n      return nu;\n    }\n    return value;\n  }(object, '$');\n};","map":{"version":3,"names":["module","exports","decycle","object","objects","paths","derez","value","path","i","name","nu","Boolean","Date","Number","RegExp","String","length","$ref","push","Object","prototype","toString","apply","hasOwnProperty","call","JSON","stringify"],"sources":["C:/Users/123/OneDrive/Desktop/git practice/git_destop/git-Check/testing/node_modules/sc-errors/decycle.js"],"sourcesContent":["// Based on https://github.com/dscape/cycle/blob/master/cycle.js\n\nmodule.exports = function decycle(object) {\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAO,GAAG,SAASC,OAAOA,CAACC,MAAM,EAAE;EAC1C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEI,IAAIC,OAAO,GAAG,EAAE;IAAI;IAChBC,KAAK,GAAG,EAAE,CAAC,CAAK;;EAEpB,OAAQ,SAASC,KAAKA,CAACC,KAAK,EAAEC,IAAI,EAAE;IAExC;;IAEQ,IAAIC,CAAC;MAAW;MACZC,IAAI;MAAQ;MACZC,EAAE,CAAC,CAAS;;IAExB;IACA;;IAEQ,IAAI,OAAOJ,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,IACvC,EAAEA,KAAK,YAAYK,OAAO,CAAC,IAC3B,EAAEL,KAAK,YAAYM,IAAI,CAAC,IACxB,EAAEN,KAAK,YAAYO,MAAM,CAAC,IAC1B,EAAEP,KAAK,YAAYQ,MAAM,CAAC,IAC1B,EAAER,KAAK,YAAYS,MAAM,CAAC,EAAE;MAE5C;MACA;MACA;;MAEY,KAAKP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,CAACa,MAAM,EAAER,CAAC,IAAI,CAAC,EAAE;QACpC,IAAIL,OAAO,CAACK,CAAC,CAAC,KAAKF,KAAK,EAAE;UACtB,OAAO;YAACW,IAAI,EAAEb,KAAK,CAACI,CAAC;UAAC,CAAC;QAC3B;MACJ;;MAEZ;;MAEYL,OAAO,CAACe,IAAI,CAACZ,KAAK,CAAC;MACnBF,KAAK,CAACc,IAAI,CAACX,IAAI,CAAC;;MAE5B;;MAEY,IAAIY,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,KAAK,CAAChB,KAAK,CAAC,KAAK,gBAAgB,EAAE;QAC7DI,EAAE,GAAG,EAAE;QACP,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACU,MAAM,EAAER,CAAC,IAAI,CAAC,EAAE;UAClCE,EAAE,CAACF,CAAC,CAAC,GAAGH,KAAK,CAACC,KAAK,CAACE,CAAC,CAAC,EAAED,IAAI,GAAG,GAAG,GAAGC,CAAC,GAAG,GAAG,CAAC;QACjD;MACJ,CAAC,MAAM;QAEnB;;QAEgBE,EAAE,GAAG,CAAC,CAAC;QACP,KAAKD,IAAI,IAAIH,KAAK,EAAE;UAChB,IAAIa,MAAM,CAACC,SAAS,CAACG,cAAc,CAACC,IAAI,CAAClB,KAAK,EAAEG,IAAI,CAAC,EAAE;YACnDC,EAAE,CAACD,IAAI,CAAC,GAAGJ,KAAK,CAACC,KAAK,CAACG,IAAI,CAAC,EACxBF,IAAI,GAAG,GAAG,GAAGkB,IAAI,CAACC,SAAS,CAACjB,IAAI,CAAC,GAAG,GAAG,CAAC;UAChD;QACJ;MACJ;MACA,OAAOC,EAAE;IACb;IACA,OAAOJ,KAAK;EAChB,CAAC,CAACJ,MAAM,EAAE,GAAG,CAAC;AAClB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}