{"ast":null,"code":"const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst validJSONStartRegex = /^[ \\n\\r\\t]*[{\\[]/;\nlet arrayBufferToBase64 = function (arraybuffer) {\n  let bytes = new Uint8Array(arraybuffer);\n  let len = bytes.length;\n  let base64 = '';\n  for (let i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n  return base64;\n};\nlet binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer) {\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    }\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\n      let rehydratedBuffer;\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n  return value;\n};\n\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\nmodule.exports.decode = function (encodedMessage) {\n  if (encodedMessage == null) {\n    return null;\n  }\n  // Leave ping or pong message as is\n  if (encodedMessage === '#1' || encodedMessage === '#2') {\n    return encodedMessage;\n  }\n  let message = encodedMessage.toString();\n\n  // Performance optimization to detect invalid JSON packet sooner.\n  if (!validJSONStartRegex.test(message)) {\n    return message;\n  }\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n  return message;\n};\n\n// Encode raw data (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\nmodule.exports.encode = function (rawData) {\n  // Leave ping or pong message as is\n  if (rawData === '#1' || rawData === '#2') {\n    return rawData;\n  }\n  return JSON.stringify(rawData, binaryToBase64Replacer);\n};","map":{"version":3,"names":["base64Chars","validJSONStartRegex","arrayBufferToBase64","arraybuffer","bytes","Uint8Array","len","length","base64","i","substring","binaryToBase64Replacer","key","value","global","ArrayBuffer","data","Buffer","toString","type","Array","isArray","rehydratedBuffer","from","module","exports","decode","encodedMessage","message","test","JSON","parse","err","encode","rawData","stringify"],"sources":["C:/Users/123/OneDrive/Desktop/git practice/git_destop/git-Check/testing/node_modules/sc-formatter/index.js"],"sourcesContent":["const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst validJSONStartRegex = /^[ \\n\\r\\t]*[{\\[]/;\n\nlet arrayBufferToBase64 = function (arraybuffer) {\n  let bytes = new Uint8Array(arraybuffer);\n  let len = bytes.length;\n  let base64 = '';\n\n  for (let i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if ((len % 3) === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nlet binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer){\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    }\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\n      let rehydratedBuffer;\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n  return value;\n};\n\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\nmodule.exports.decode = function (encodedMessage) {\n  if (encodedMessage == null) {\n   return null;\n  }\n  // Leave ping or pong message as is\n  if (encodedMessage === '#1' || encodedMessage === '#2') {\n    return encodedMessage;\n  }\n  let message = encodedMessage.toString();\n\n  // Performance optimization to detect invalid JSON packet sooner.\n  if (!validJSONStartRegex.test(message)) {\n    return message;\n  }\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n  return message;\n};\n\n// Encode raw data (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\nmodule.exports.encode = function (rawData) {\n  // Leave ping or pong message as is\n  if (rawData === '#1' || rawData === '#2') {\n    return rawData;\n  }\n  return JSON.stringify(rawData, binaryToBase64Replacer);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}