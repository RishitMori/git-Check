{"ast":null,"code":"var pathGetter = require('./path-getter');\nvar utils = require('./utils');\nvar WMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {\n  var keys = [];\n  var values = [];\n  return {\n    set: function (key, value) {\n      keys.push(key);\n      values.push(value);\n    },\n    get: function (key) {\n      for (var i = 0; i < keys.length; i++) {\n        if (keys[i] === key) {\n          return values[i];\n        }\n      }\n    }\n  };\n};\n\n// Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n\nexports.decycle = function decycle(object, options, replacer, map) {\n  'use strict';\n\n  map = map || new WMap();\n  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');\n  var withRefs = options.refs !== false;\n  return function derez(_value, path, key) {\n    // The derez recurses through the object, producing the deep copy.\n\n    var i,\n      // The loop counter\n      name,\n      // Property name\n      nu; // The new object or array\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;\n    if (options.date && value instanceof Date) {\n      return {\n        $jsan: 'd' + value.getTime()\n      };\n    }\n    if (options.regex && value instanceof RegExp) {\n      return {\n        $jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source\n      };\n    }\n    if (options['function'] && typeof value === 'function') {\n      return {\n        $jsan: 'f' + utils.stringifyFunction(value, options['function'])\n      };\n    }\n    if (options['nan'] && typeof value === 'number' && isNaN(value)) {\n      return {\n        $jsan: 'n'\n      };\n    }\n    if (options['infinity']) {\n      if (Number.POSITIVE_INFINITY === value) return {\n        $jsan: 'i'\n      };\n      if (Number.NEGATIVE_INFINITY === value) return {\n        $jsan: 'y'\n      };\n    }\n    if (options['undefined'] && value === undefined) {\n      return {\n        $jsan: 'u'\n      };\n    }\n    if (options['error'] && value instanceof Error) {\n      return {\n        $jsan: 'e' + value.message\n      };\n    }\n    if (options['symbol'] && typeof value === 'symbol') {\n      var symbolKey = Symbol.keyFor(value);\n      if (symbolKey !== undefined) {\n        return {\n          $jsan: 'g' + symbolKey\n        };\n      }\n\n      // 'Symbol(foo)'.slice(7, -1) === 'foo'\n      return {\n        $jsan: 's' + value.toString().slice(7, -1)\n      };\n    }\n    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {\n      return {\n        $jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer, map))\n      };\n    }\n    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {\n      return {\n        $jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer, map))\n      };\n    }\n    if (value && typeof value.toJSON === 'function') {\n      try {\n        value = value.toJSON(key);\n      } catch (error) {\n        var keyString = key || '$';\n        return \"toJSON failed for '\" + (map.get(value) || keyString) + \"'\";\n      }\n    }\n    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String) && !(typeof value === 'symbol') && !(value instanceof Error)) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object.\n\n      if (typeof value === 'object') {\n        var foundPath = map.get(value);\n        if (foundPath) {\n          if (noCircularOption && withRefs) {\n            return {\n              $jsan: foundPath\n            };\n          }\n\n          // This is only a true circular reference if the parent path is inside of foundPath\n          // drop the last component of the current path and check if it starts with foundPath\n          var parentPath = path.split('.').slice(0, -1).join('.');\n          if (parentPath.indexOf(foundPath) === 0) {\n            if (!noCircularOption) {\n              return typeof options.circular === 'function' ? options.circular(value, path, foundPath) : options.circular;\n            }\n            return {\n              $jsan: foundPath\n            };\n          }\n          if (withRefs) return {\n            $jsan: foundPath\n          };\n        }\n        map.set(value, path);\n      }\n\n      // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        nu = [];\n        for (i = 0; i < value.length; i += 1) {\n          nu[i] = derez(value[i], path + '[' + i + ']', i);\n        }\n      } else {\n        // If it is an object, replicate the object.\n\n        nu = {};\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            var nextPath = /^\\w+$/.test(name) ? '.' + name : '[' + JSON.stringify(name) + ']';\n            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);\n          }\n        }\n      }\n      return nu;\n    }\n    return value;\n  }(object, '$');\n};\nexports.retrocycle = function retrocycle($) {\n  'use strict';\n\n  return function rez(value) {\n    // The rez function walks recursively through the object looking for $jsan\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $jsan object with a reference to the value that is found by\n    // the path.\n\n    var i, item, name, path;\n    if (value && typeof value === 'object') {\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i];\n          if (item && typeof item === 'object') {\n            if (item.$jsan) {\n              value[i] = utils.restore(item.$jsan, $);\n            } else {\n              rez(item);\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          // base case passed raw object\n          if (typeof value[name] === 'string' && name === '$jsan') {\n            return utils.restore(value.$jsan, $);\n            break;\n          } else {\n            if (name === '$jsan') {\n              value[name] = value[name][0];\n            }\n            if (typeof value[name] === 'object') {\n              item = value[name];\n              if (item && typeof item === 'object') {\n                if (item.$jsan) {\n                  value[name] = utils.restore(item.$jsan, $);\n                } else {\n                  rez(item);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return value;\n  }($);\n};","map":{"version":3,"names":["pathGetter","require","utils","WMap","WeakMap","keys","values","set","key","value","push","get","i","length","exports","decycle","object","options","replacer","map","noCircularOption","Object","prototype","hasOwnProperty","call","withRefs","refs","derez","_value","path","name","nu","date","Date","$jsan","getTime","regex","RegExp","getRegexFlags","source","stringifyFunction","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","undefined","Error","message","symbolKey","Symbol","keyFor","toString","slice","Map","Array","from","JSON","stringify","Set","toJSON","error","keyString","Boolean","String","foundPath","parentPath","split","join","indexOf","circular","apply","nextPath","test","retrocycle","$","rez","item","restore"],"sources":["C:/Users/123/OneDrive/Desktop/git practice/git_destop/git-Check/testing/node_modules/jsan/lib/cycle.js"],"sourcesContent":["var pathGetter = require('./path-getter');\nvar utils = require('./utils');\n\nvar WMap = typeof WeakMap !== 'undefined'?\n  WeakMap:\n  function() {\n    var keys = [];\n    var values = [];\n    return {\n      set: function(key, value) {\n        keys.push(key);\n        values.push(value);\n      },\n      get: function(key) {\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i] === key) {\n            return values[i];\n          }\n        }\n      }\n    }\n  };\n\n// Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n\nexports.decycle = function decycle(object, options, replacer, map) {\n  'use strict';\n\n  map = map || new WMap();\n\n  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');\n  var withRefs = options.refs !== false;\n\n  return (function derez(_value, path, key) {\n\n    // The derez recurses through the object, producing the deep copy.\n\n    var i,        // The loop counter\n      name,       // Property name\n      nu;         // The new object or array\n\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;\n\n    if (options.date && value instanceof Date) {\n      return {$jsan: 'd' + value.getTime()};\n    }\n    if (options.regex && value instanceof RegExp) {\n      return {$jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source};\n    }\n    if (options['function'] && typeof value === 'function') {\n      return {$jsan: 'f' + utils.stringifyFunction(value, options['function'])}\n    }\n    if (options['nan'] && typeof value === 'number' && isNaN(value)) {\n      return {$jsan: 'n'}\n    }\n    if (options['infinity']) {\n      if (Number.POSITIVE_INFINITY === value) return {$jsan: 'i'}\n      if (Number.NEGATIVE_INFINITY === value) return {$jsan: 'y'}\n    }\n    if (options['undefined'] && value === undefined) {\n      return {$jsan: 'u'}\n    }\n    if (options['error'] && value instanceof Error) {\n      return {$jsan: 'e' + value.message}\n    }\n    if (options['symbol'] && typeof value === 'symbol') {\n      var symbolKey = Symbol.keyFor(value)\n      if (symbolKey !== undefined) {\n        return {$jsan: 'g' + symbolKey}\n      }\n\n      // 'Symbol(foo)'.slice(7, -1) === 'foo'\n      return {$jsan: 's' + value.toString().slice(7, -1)}\n    }\n\n    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {\n      return {$jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer, map))}\n    }\n\n    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {\n      return {$jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer, map))}\n    }\n\n    if (value && typeof value.toJSON === 'function') {\n      try {\n        value = value.toJSON(key);\n      } catch (error) {\n        var keyString = (key || '$');\n        return \"toJSON failed for '\" + (map.get(value) || keyString) + \"'\";\n      }\n    }\n\n    if (typeof value === 'object' && value !== null &&\n      !(value instanceof Boolean) &&\n      !(value instanceof Date)    &&\n      !(value instanceof Number)  &&\n      !(value instanceof RegExp)  &&\n      !(value instanceof String)  &&\n      !(typeof value === 'symbol')  &&\n      !(value instanceof Error)) {\n\n        // If the value is an object or array, look to see if we have already\n        // encountered it. If so, return a $ref/path object.\n\n      if (typeof value === 'object') {\n        var foundPath = map.get(value);\n        if (foundPath) {\n          if (noCircularOption && withRefs) {\n            return {$jsan: foundPath};\n          }\n          \n          // This is only a true circular reference if the parent path is inside of foundPath\n          // drop the last component of the current path and check if it starts with foundPath\n          var parentPath = path.split('.').slice(0, -1).join('.');\n          if (parentPath.indexOf(foundPath) === 0) {\n            if (!noCircularOption) {\n              return typeof options.circular === 'function'?\n              options.circular(value, path, foundPath):\n              options.circular;\n            }\n            return {$jsan: foundPath};\n          }\n          if (withRefs) return {$jsan: foundPath};\n        }\n        map.set(value, path);\n      }\n\n\n      // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n          nu = [];\n          for (i = 0; i < value.length; i += 1) {\n              nu[i] = derez(value[i], path + '[' + i + ']', i);\n          }\n      } else {\n\n        // If it is an object, replicate the object.\n\n        nu = {};\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            var nextPath = /^\\w+$/.test(name) ?\n              '.' + name :\n              '[' + JSON.stringify(name) + ']';\n            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);\n          }\n        }\n      }\n      return nu;\n    }\n    return value;\n  }(object, '$'));\n};\n\n\nexports.retrocycle = function retrocycle($) {\n  'use strict';\n\n\n  return (function rez(value) {\n\n    // The rez function walks recursively through the object looking for $jsan\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $jsan object with a reference to the value that is found by\n    // the path.\n\n    var i, item, name, path;\n\n    if (value && typeof value === 'object') {\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i];\n          if (item && typeof item === 'object') {\n            if (item.$jsan) {\n              value[i] = utils.restore(item.$jsan, $);\n            } else {\n              rez(item);\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          // base case passed raw object\n          if(typeof value[name] === 'string' && name === '$jsan'){\n            return utils.restore(value.$jsan, $);\n            break;\n          }\n          else {\n            if (name === '$jsan') {\n              value[name] = value[name][0];\n            }\n            if (typeof value[name] === 'object') {\n              item = value[name];\n              if (item && typeof item === 'object') {\n                if (item.$jsan) {\n                  value[name] = utils.restore(item.$jsan, $);\n                } else {\n                  rez(item);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return value;\n  }($));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}