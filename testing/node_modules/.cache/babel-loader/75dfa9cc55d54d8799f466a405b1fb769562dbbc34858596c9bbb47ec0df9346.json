{"ast":null,"code":"var Emitter = require('component-emitter');\nvar SCChannel = require('sc-channel').SCChannel;\nvar Response = require('./response').Response;\nvar AuthEngine = require('./auth').AuthEngine;\nvar formatter = require('sc-formatter');\nvar SCTransport = require('./sctransport').SCTransport;\nvar querystring = require('querystring');\nvar LinkedList = require('linked-list');\nvar Buffer = require('buffer/').Buffer;\nvar clone = require('clone');\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidMessageError = scErrors.InvalidMessageError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar SocketProtocolError = scErrors.SocketProtocolError;\nvar TimeoutError = scErrors.TimeoutError;\nvar BadConnectionError = scErrors.BadConnectionError;\nvar isBrowser = typeof window !== 'undefined';\nvar SCClientSocket = function (opts) {\n  var self = this;\n  Emitter.call(this);\n  this.id = null;\n  this.state = this.CLOSED;\n  this.authState = this.UNAUTHENTICATED;\n  this.signedAuthToken = null;\n  this.authToken = null;\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  this.preparingPendingSubscriptions = false;\n  this.clientId = opts.clientId;\n  this.connectTimeout = opts.connectTimeout;\n  this.ackTimeout = opts.ackTimeout;\n  this.channelPrefix = opts.channelPrefix || null;\n  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n  this.authTokenName = opts.authTokenName;\n\n  // pingTimeout will be ackTimeout at the start, but it will\n  // be updated with values provided by the 'connect' event\n  this.pingTimeout = this.ackTimeout;\n  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;\n  this.active = true;\n  this._clientMap = opts.clientMap || {};\n  var maxTimeout = Math.pow(2, 31) - 1;\n  var verifyDuration = function (propertyName) {\n    if (self[propertyName] > maxTimeout) {\n      throw new InvalidArgumentsError('The ' + propertyName + ' value provided exceeded the maximum amount allowed');\n    }\n  };\n  verifyDuration('connectTimeout');\n  verifyDuration('ackTimeout');\n  this._localEvents = {\n    'connect': 1,\n    'connectAbort': 1,\n    'close': 1,\n    'disconnect': 1,\n    'message': 1,\n    'error': 1,\n    'raw': 1,\n    'kickOut': 1,\n    'subscribe': 1,\n    'unsubscribe': 1,\n    'subscribeStateChange': 1,\n    'authStateChange': 1,\n    'authenticate': 1,\n    'deauthenticate': 1,\n    'removeAuthToken': 1,\n    'subscribeRequest': 1\n  };\n  this.connectAttempts = 0;\n  this._emitBuffer = new LinkedList();\n  this.channels = {};\n  this.options = opts;\n  this._cid = 1;\n  this.options.callIdGenerator = function () {\n    return self._cid++;\n  };\n  if (this.options.autoReconnect) {\n    if (this.options.autoReconnectOptions == null) {\n      this.options.autoReconnectOptions = {};\n    }\n\n    // Add properties to the this.options.autoReconnectOptions object.\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\n    var reconnectOptions = this.options.autoReconnectOptions;\n    if (reconnectOptions.initialDelay == null) {\n      reconnectOptions.initialDelay = 10000;\n    }\n    if (reconnectOptions.randomness == null) {\n      reconnectOptions.randomness = 10000;\n    }\n    if (reconnectOptions.multiplier == null) {\n      reconnectOptions.multiplier = 1.5;\n    }\n    if (reconnectOptions.maxDelay == null) {\n      reconnectOptions.maxDelay = 60000;\n    }\n  }\n  if (this.options.subscriptionRetryOptions == null) {\n    this.options.subscriptionRetryOptions = {};\n  }\n  if (this.options.authEngine) {\n    this.auth = this.options.authEngine;\n  } else {\n    this.auth = new AuthEngine();\n  }\n  if (this.options.codecEngine) {\n    this.codec = this.options.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n  if (this.options.protocol) {\n    var protocolOptionError = new InvalidArgumentsError('The \"protocol\" option' + ' does not affect socketcluster-client. If you want to utilize SSL/TLS' + ' - use \"secure\" option instead');\n    this._onSCError(protocolOptionError);\n  }\n  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n  this.options.query = opts.query || {};\n  if (typeof this.options.query === 'string') {\n    this.options.query = querystring.parse(this.options.query);\n  }\n  this._channelEmitter = new Emitter();\n  this._unloadHandler = function () {\n    self.disconnect();\n  };\n  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n    global.addEventListener('beforeunload', this._unloadHandler, false);\n  }\n  this._clientMap[this.clientId] = this;\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\nSCClientSocket.prototype = Object.create(Emitter.prototype);\nSCClientSocket.CONNECTING = SCClientSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\nSCClientSocket.OPEN = SCClientSocket.prototype.OPEN = SCTransport.prototype.OPEN;\nSCClientSocket.CLOSED = SCClientSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\nSCClientSocket.AUTHENTICATED = SCClientSocket.prototype.AUTHENTICATED = 'authenticated';\nSCClientSocket.UNAUTHENTICATED = SCClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\nSCClientSocket.PENDING = SCClientSocket.prototype.PENDING = 'pending';\nSCClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\nSCClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\nSCClientSocket.prototype._privateEventHandlerMap = {\n  '#publish': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n    if (isSubscribed) {\n      this._channelEmitter.emit(undecoratedChannelName, data.data);\n    }\n  },\n  '#kickOut': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var channel = this.channels[undecoratedChannelName];\n    if (channel) {\n      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n      channel.emit('kickOut', data.message, undecoratedChannelName);\n      this._triggerChannelUnsubscribe(channel);\n    }\n  },\n  '#setAuthToken': function (data, response) {\n    var self = this;\n    if (data) {\n      var triggerAuthenticate = function (err) {\n        if (err) {\n          // This is a non-fatal error, we don't want to close the connection\n          // because of this but we do want to notify the server and throw an error\n          // on the client.\n          response.error(err);\n          self._onSCError(err);\n        } else {\n          self._changeToAuthenticatedState(data.token);\n          response.end();\n        }\n      };\n      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n    } else {\n      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n    }\n  },\n  '#removeAuthToken': function (data, response) {\n    var self = this;\n    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n      if (err) {\n        // Non-fatal error - Do not close the connection\n        response.error(err);\n        self._onSCError(err);\n      } else {\n        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n        self._changeToUnauthenticatedStateAndClearTokens();\n        response.end();\n      }\n    });\n  },\n  '#disconnect': function (data) {\n    this.transport.close(data.code, data.data);\n  }\n};\nSCClientSocket.prototype.getState = function () {\n  return this.state;\n};\nSCClientSocket.prototype.getBytesReceived = function () {\n  return this.transport.getBytesReceived();\n};\nSCClientSocket.prototype.deauthenticate = function (callback) {\n  var self = this;\n  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n    if (err) {\n      // Non-fatal error - Do not close the connection\n      self._onSCError(err);\n    } else {\n      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n      if (self.state !== self.CLOSED) {\n        self.emit('#removeAuthToken');\n      }\n      self._changeToUnauthenticatedStateAndClearTokens();\n    }\n    callback && callback(err);\n  });\n};\nSCClientSocket.prototype.connect = SCClientSocket.prototype.open = function () {\n  var self = this;\n  if (!this.active) {\n    var error = new InvalidActionError('Cannot connect a destroyed client');\n    this._onSCError(error);\n    return;\n  }\n  if (this.state === this.CLOSED) {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n    this.state = this.CONNECTING;\n    Emitter.prototype.emit.call(this, 'connecting');\n    if (this.transport) {\n      this.transport.off();\n    }\n    this.transport = new SCTransport(this.auth, this.codec, this.options);\n    this.transport.on('open', function (status) {\n      self.state = self.OPEN;\n      self._onSCOpen(status);\n    });\n    this.transport.on('error', function (err) {\n      self._onSCError(err);\n    });\n    this.transport.on('close', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data);\n    });\n    this.transport.on('openAbort', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data, true);\n    });\n    this.transport.on('event', function (event, data, res) {\n      self._onSCEvent(event, data, res);\n    });\n  }\n};\nSCClientSocket.prototype.reconnect = function (code, data) {\n  this.disconnect(code, data);\n  this.connect();\n};\nSCClientSocket.prototype.disconnect = function (code, data) {\n  code = code || 1000;\n  if (typeof code !== 'number') {\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n  }\n  if (this.state === this.OPEN || this.state === this.CONNECTING) {\n    this.transport.close(code, data);\n  } else {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n  }\n};\nSCClientSocket.prototype.destroy = function (code, data) {\n  if (isBrowser && global.removeEventListener) {\n    global.removeEventListener('beforeunload', this._unloadHandler, false);\n  }\n  this.active = false;\n  this.disconnect(code, data);\n  delete this._clientMap[this.clientId];\n};\nSCClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n  if (this.authState !== this.UNAUTHENTICATED) {\n    var oldState = this.authState;\n    var oldSignedToken = this.signedAuthToken;\n    this.authState = this.UNAUTHENTICATED;\n    this.signedAuthToken = null;\n    this.authToken = null;\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState\n    };\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'deauthenticate', oldSignedToken);\n  }\n};\nSCClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n  this.signedAuthToken = signedAuthToken;\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\n  if (this.authState !== this.AUTHENTICATED) {\n    var oldState = this.authState;\n    this.authState = this.AUTHENTICATED;\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState,\n      signedAuthToken: signedAuthToken,\n      authToken: this.authToken\n    };\n    if (!this.preparingPendingSubscriptions) {\n      this.processPendingSubscriptions();\n    }\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n  }\n  Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n};\nSCClientSocket.prototype.decodeBase64 = function (encodedString) {\n  return Buffer.from(encodedString, 'base64').toString('utf8');\n};\nSCClientSocket.prototype.encodeBase64 = function (decodedString) {\n  return Buffer.from(decodedString, 'utf8').toString('base64');\n};\nSCClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n  var tokenParts = (signedAuthToken || '').split('.');\n  var encodedTokenData = tokenParts[1];\n  if (encodedTokenData != null) {\n    var tokenData = encodedTokenData;\n    try {\n      tokenData = this.decodeBase64(tokenData);\n      return JSON.parse(tokenData);\n    } catch (e) {\n      return tokenData;\n    }\n  }\n  return null;\n};\nSCClientSocket.prototype.getAuthToken = function () {\n  return this.authToken;\n};\nSCClientSocket.prototype.getSignedAuthToken = function () {\n  return this.signedAuthToken;\n};\n\n// Perform client-initiated authentication by providing an encrypted token string.\nSCClientSocket.prototype.authenticate = function (signedAuthToken, callback) {\n  var self = this;\n  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n    if (authStatus && authStatus.isAuthenticated != null) {\n      // If authStatus is correctly formatted (has an isAuthenticated property),\n      // then we will rehydrate the authError.\n      if (authStatus.authError) {\n        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n      }\n    } else {\n      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n      // authStatus object to the current function, so we need to create it ourselves.\n      authStatus = {\n        isAuthenticated: self.authState,\n        authError: null\n      };\n    }\n    if (err) {\n      if (err.name !== 'BadConnectionError' && err.name !== 'TimeoutError') {\n        // In case of a bad/closed connection or a timeout, we maintain the last\n        // known auth state since those errors don't mean that the token is invalid.\n\n        self._changeToUnauthenticatedStateAndClearTokens();\n      }\n      callback && callback(err, authStatus);\n    } else {\n      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n        if (err) {\n          self._onSCError(err);\n        }\n        if (authStatus.isAuthenticated) {\n          self._changeToAuthenticatedState(signedAuthToken);\n        } else {\n          self._changeToUnauthenticatedStateAndClearTokens();\n        }\n        callback && callback(err, authStatus);\n      });\n    }\n  });\n};\nSCClientSocket.prototype._tryReconnect = function (initialDelay) {\n  var self = this;\n  var exponent = this.connectAttempts++;\n  var reconnectOptions = this.options.autoReconnectOptions;\n  var timeout;\n  if (initialDelay == null || exponent > 0) {\n    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n  } else {\n    timeout = initialDelay;\n  }\n  if (timeout > reconnectOptions.maxDelay) {\n    timeout = reconnectOptions.maxDelay;\n  }\n  clearTimeout(this._reconnectTimeoutRef);\n  this.pendingReconnect = true;\n  this.pendingReconnectTimeout = timeout;\n  this._reconnectTimeoutRef = setTimeout(function () {\n    self.connect();\n  }, timeout);\n};\nSCClientSocket.prototype._onSCOpen = function (status) {\n  var self = this;\n  this.preparingPendingSubscriptions = true;\n  if (status) {\n    this.id = status.id;\n    this.pingTimeout = status.pingTimeout;\n    this.transport.pingTimeout = this.pingTimeout;\n    if (status.isAuthenticated) {\n      this._changeToAuthenticatedState(status.authToken);\n    } else {\n      this._changeToUnauthenticatedStateAndClearTokens();\n    }\n  } else {\n    // This can happen if auth.loadToken (in sctransport.js) fails with\n    // an error - This means that the signedAuthToken cannot be loaded by\n    // the auth engine and therefore, we need to unauthenticate the client.\n    this._changeToUnauthenticatedStateAndClearTokens();\n  }\n  this.connectAttempts = 0;\n  if (this.options.autoSubscribeOnConnect) {\n    this.processPendingSubscriptions();\n  }\n\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n  // won't break anything.\n  Emitter.prototype.emit.call(this, 'connect', status, function () {\n    self.processPendingSubscriptions();\n  });\n  if (this.state === this.OPEN) {\n    this._flushEmitBuffer();\n  }\n};\nSCClientSocket.prototype._onSCError = function (err) {\n  var self = this;\n\n  // Throw error in different stack frame so that error handling\n  // cannot interfere with a reconnect action.\n  setTimeout(function () {\n    if (self.listeners('error').length < 1) {\n      throw err;\n    } else {\n      Emitter.prototype.emit.call(self, 'error', err);\n    }\n  }, 0);\n};\nSCClientSocket.prototype._suspendSubscriptions = function () {\n  var channel, newState;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n      if (channel.state === channel.SUBSCRIBED || channel.state === channel.PENDING) {\n        newState = channel.PENDING;\n      } else {\n        newState = channel.UNSUBSCRIBED;\n      }\n      this._triggerChannelUnsubscribe(channel, newState);\n    }\n  }\n};\nSCClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    clearTimeout(eventObject.timeout);\n    delete eventObject.timeout;\n    currentNode.detach();\n    currentNode = nextNode;\n    var callback = eventObject.callback;\n    if (callback) {\n      delete eventObject.callback;\n      var errorMessage = \"Event '\" + eventObject.event + \"' was aborted due to a bad connection\";\n      var error = new BadConnectionError(errorMessage, failureType);\n      callback.call(eventObject, error, eventObject);\n    }\n    // Cleanup any pending response callback in the transport layer too.\n    if (eventObject.cid) {\n      this.transport.cancelPendingResponse(eventObject.cid);\n    }\n  }\n};\nSCClientSocket.prototype._onSCClose = function (code, data, openAbort) {\n  var self = this;\n  this.id = null;\n  if (this.transport) {\n    this.transport.off();\n  }\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  clearTimeout(this._reconnectTimeoutRef);\n  this._suspendSubscriptions();\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\n  // Try to reconnect\n  // on server ping timeout (4000)\n  // or on client pong timeout (4001)\n  // or on close without status (1005)\n  // or on handshake failure (4003)\n  // or on handshake rejection (4008)\n  // or on socket hung up (1006)\n  if (this.options.autoReconnect) {\n    if (code === 4000 || code === 4001 || code === 1005) {\n      // If there is a ping or pong timeout or socket closes without\n      // status, don't wait before trying to reconnect - These could happen\n      // if the client wakes up after a period of inactivity and in this case we\n      // want to re-establish the connection as soon as possible.\n      this._tryReconnect(0);\n\n      // Codes 4500 and above will be treated as permanent disconnects.\n      // Socket will not try to auto-reconnect.\n    } else if (code !== 1000 && code < 4500) {\n      this._tryReconnect();\n    }\n  }\n  if (openAbort) {\n    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n  } else {\n    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n  }\n  Emitter.prototype.emit.call(self, 'close', code, data);\n  if (!SCClientSocket.ignoreStatuses[code]) {\n    var closeMessage;\n    if (data) {\n      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + data;\n    } else {\n      closeMessage = 'Socket connection closed with status code ' + code;\n    }\n    var err = new SocketProtocolError(SCClientSocket.errorStatuses[code] || closeMessage, code);\n    this._onSCError(err);\n  }\n};\nSCClientSocket.prototype._onSCEvent = function (event, data, res) {\n  var handler = this._privateEventHandlerMap[event];\n  if (handler) {\n    handler.call(this, data, res);\n  } else {\n    Emitter.prototype.emit.call(this, event, data, function () {\n      res && res.callback.apply(res, arguments);\n    });\n  }\n};\nSCClientSocket.prototype.decode = function (message) {\n  return this.transport.decode(message);\n};\nSCClientSocket.prototype.encode = function (object) {\n  return this.transport.encode(object);\n};\nSCClientSocket.prototype._flushEmitBuffer = function () {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    currentNode.detach();\n    this.transport.emitObject(eventObject);\n    currentNode = nextNode;\n  }\n};\nSCClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n  if (eventNode) {\n    eventNode.detach();\n  }\n  delete eventObject.timeout;\n  var callback = eventObject.callback;\n  if (callback) {\n    delete eventObject.callback;\n    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n    callback.call(eventObject, error, eventObject);\n  }\n  // Cleanup any pending response callback in the transport layer too.\n  if (eventObject.cid) {\n    this.transport.cancelPendingResponse(eventObject.cid);\n  }\n};\nSCClientSocket.prototype._emit = function (event, data, callback) {\n  var self = this;\n  if (this.state === this.CLOSED) {\n    this.connect();\n  }\n  var eventObject = {\n    event: event,\n    callback: callback\n  };\n  var eventNode = new LinkedList.Item();\n  if (this.options.cloneData) {\n    eventObject.data = clone(data);\n  } else {\n    eventObject.data = data;\n  }\n  eventNode.data = eventObject;\n  eventObject.timeout = setTimeout(function () {\n    self._handleEventAckTimeout(eventObject, eventNode);\n  }, this.ackTimeout);\n  this._emitBuffer.append(eventNode);\n  if (this.state === this.OPEN) {\n    this._flushEmitBuffer();\n  }\n};\nSCClientSocket.prototype.send = function (data) {\n  this.transport.send(data);\n};\nSCClientSocket.prototype.emit = function (event, data, callback) {\n  if (this._localEvents[event] == null) {\n    this._emit(event, data, callback);\n  } else if (event === 'error') {\n    Emitter.prototype.emit.call(this, event, data);\n  } else {\n    var error = new InvalidActionError('The \"' + event + '\" event is reserved and cannot be emitted on a client socket');\n    this._onSCError(error);\n  }\n};\nSCClientSocket.prototype.publish = function (channelName, data, callback) {\n  var pubData = {\n    channel: this._decorateChannelName(channelName),\n    data: data\n  };\n  this.emit('#publish', pubData, callback);\n};\nSCClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n  var channelName = channel.name;\n  if (channel.state !== channel.SUBSCRIBED) {\n    var oldState = channel.state;\n    channel.state = channel.SUBSCRIBED;\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state,\n      subscriptionOptions: subscriptionOptions\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('subscribe', channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n  }\n};\nSCClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n  var channelName = channel.name;\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\n  if (channel.state !== channel.UNSUBSCRIBED && meetsAuthRequirements) {\n    channel.state = channel.UNSUBSCRIBED;\n    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n  }\n};\n\n// Cancel any pending subscribe callback\nSCClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n  if (channel._pendingSubscriptionCid != null) {\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n    delete channel._pendingSubscriptionCid;\n  }\n};\nSCClientSocket.prototype._decorateChannelName = function (channelName) {\n  if (this.channelPrefix) {\n    channelName = this.channelPrefix + channelName;\n  }\n  return channelName;\n};\nSCClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) === 0) {\n    return decoratedChannelName.replace(this.channelPrefix, '');\n  }\n  return decoratedChannelName;\n};\nSCClientSocket.prototype._trySubscribe = function (channel) {\n  var self = this;\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\n\n  // We can only ever have one pending subscribe action at any given time on a channel\n  if (this.state === this.OPEN && !this.preparingPendingSubscriptions && channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n    var options = {\n      noTimeout: true\n    };\n    var subscriptionOptions = {\n      channel: this._decorateChannelName(channel.name)\n    };\n    if (channel.waitForAuth) {\n      options.waitForAuth = true;\n      subscriptionOptions.waitForAuth = options.waitForAuth;\n    }\n    if (channel.data) {\n      subscriptionOptions.data = channel.data;\n    }\n    if (channel.batch) {\n      options.batch = true;\n      subscriptionOptions.batch = true;\n    }\n    channel._pendingSubscriptionCid = this.transport.emit('#subscribe', subscriptionOptions, options, function (err) {\n      delete channel._pendingSubscriptionCid;\n      if (err) {\n        self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n      } else {\n        self._triggerChannelSubscribe(channel, subscriptionOptions);\n      }\n    });\n    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n  }\n};\nSCClientSocket.prototype.subscribe = function (channelName, options) {\n  var channel = this.channels[channelName];\n  if (!channel) {\n    channel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = channel;\n  } else if (options) {\n    channel.setOptions(options);\n  }\n  if (channel.state === channel.UNSUBSCRIBED) {\n    channel.state = channel.PENDING;\n    this._trySubscribe(channel);\n  }\n  return channel;\n};\nSCClientSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n  var channelName = channel.name;\n  var oldState = channel.state;\n  if (newState) {\n    channel.state = newState;\n  } else {\n    channel.state = channel.UNSUBSCRIBED;\n  }\n  this._cancelPendingSubscribeCallback(channel);\n  if (oldState === channel.SUBSCRIBED) {\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('unsubscribe', channelName);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n  }\n};\nSCClientSocket.prototype._tryUnsubscribe = function (channel) {\n  var self = this;\n  if (this.state === this.OPEN) {\n    var options = {\n      noTimeout: true\n    };\n    if (channel.batch) {\n      options.batch = true;\n    }\n    // If there is a pending subscribe action, cancel the callback\n    this._cancelPendingSubscribeCallback(channel);\n\n    // This operation cannot fail because the TCP protocol guarantees delivery\n    // so long as the connection remains open. If the connection closes,\n    // the server will automatically unsubscribe the client and thus complete\n    // the operation on the server side.\n    var decoratedChannelName = this._decorateChannelName(channel.name);\n    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n  }\n};\nSCClientSocket.prototype.unsubscribe = function (channelName) {\n  var channel = this.channels[channelName];\n  if (channel) {\n    if (channel.state !== channel.UNSUBSCRIBED) {\n      this._triggerChannelUnsubscribe(channel);\n      this._tryUnsubscribe(channel);\n    }\n  }\n};\nSCClientSocket.prototype.channel = function (channelName, options) {\n  var currentChannel = this.channels[channelName];\n  if (!currentChannel) {\n    currentChannel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = currentChannel;\n  }\n  return currentChannel;\n};\nSCClientSocket.prototype.destroyChannel = function (channelName) {\n  var channel = this.channels[channelName];\n  if (channel) {\n    channel.unwatch();\n    channel.unsubscribe();\n    delete this.channels[channelName];\n  }\n};\nSCClientSocket.prototype.subscriptions = function (includePending) {\n  var subs = [];\n  var channel, includeChannel;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n      if (includePending) {\n        includeChannel = channel && (channel.state === channel.SUBSCRIBED || channel.state === channel.PENDING);\n      } else {\n        includeChannel = channel && channel.state === channel.SUBSCRIBED;\n      }\n      if (includeChannel) {\n        subs.push(channelName);\n      }\n    }\n  }\n  return subs;\n};\nSCClientSocket.prototype.isSubscribed = function (channelName, includePending) {\n  var channel = this.channels[channelName];\n  if (includePending) {\n    return !!channel && (channel.state === channel.SUBSCRIBED || channel.state === channel.PENDING);\n  }\n  return !!channel && channel.state === channel.SUBSCRIBED;\n};\nSCClientSocket.prototype.processPendingSubscriptions = function () {\n  var self = this;\n  this.preparingPendingSubscriptions = false;\n  var pendingChannels = [];\n  for (var i in this.channels) {\n    if (this.channels.hasOwnProperty(i)) {\n      var channel = this.channels[i];\n      if (channel.state === channel.PENDING) {\n        pendingChannels.push(channel);\n      }\n    }\n  }\n  pendingChannels.sort(function (a, b) {\n    var ap = a.priority || 0;\n    var bp = b.priority || 0;\n    if (ap > bp) {\n      return -1;\n    }\n    if (ap < bp) {\n      return 1;\n    }\n    return 0;\n  });\n  pendingChannels.forEach(function (channel) {\n    self._trySubscribe(channel);\n  });\n};\nSCClientSocket.prototype.watch = function (channelName, handler) {\n  if (typeof handler !== 'function') {\n    throw new InvalidArgumentsError('No handler function was provided');\n  }\n  this._channelEmitter.on(channelName, handler);\n};\nSCClientSocket.prototype.unwatch = function (channelName, handler) {\n  if (handler) {\n    this._channelEmitter.removeListener(channelName, handler);\n  } else {\n    this._channelEmitter.removeAllListeners(channelName);\n  }\n};\nSCClientSocket.prototype.watchers = function (channelName) {\n  return this._channelEmitter.listeners(channelName);\n};\nmodule.exports = SCClientSocket;","map":{"version":3,"names":["Emitter","require","SCChannel","Response","AuthEngine","formatter","SCTransport","querystring","LinkedList","Buffer","clone","scErrors","InvalidArgumentsError","InvalidMessageError","InvalidActionError","SocketProtocolError","TimeoutError","BadConnectionError","isBrowser","window","SCClientSocket","opts","self","call","id","state","CLOSED","authState","UNAUTHENTICATED","signedAuthToken","authToken","pendingReconnect","pendingReconnectTimeout","preparingPendingSubscriptions","clientId","connectTimeout","ackTimeout","channelPrefix","disconnectOnUnload","authTokenName","pingTimeout","pingTimeoutDisabled","active","_clientMap","clientMap","maxTimeout","Math","pow","verifyDuration","propertyName","_localEvents","connectAttempts","_emitBuffer","channels","options","_cid","callIdGenerator","autoReconnect","autoReconnectOptions","reconnectOptions","initialDelay","randomness","multiplier","maxDelay","subscriptionRetryOptions","authEngine","auth","codecEngine","codec","protocol","protocolOptionError","_onSCError","path","replace","query","parse","_channelEmitter","_unloadHandler","disconnect","global","addEventListener","autoConnect","connect","prototype","Object","create","CONNECTING","OPEN","AUTHENTICATED","PENDING","ignoreStatuses","socketProtocolIgnoreStatuses","errorStatuses","socketProtocolErrorStatuses","_privateEventHandlerMap","#publish","data","undecoratedChannelName","_undecorateChannelName","channel","isSubscribed","emit","#kickOut","message","_triggerChannelUnsubscribe","#setAuthToken","response","triggerAuthenticate","err","error","_changeToAuthenticatedState","token","end","saveToken","#removeAuthToken","removeToken","oldToken","_changeToUnauthenticatedStateAndClearTokens","#disconnect","transport","close","code","getState","getBytesReceived","deauthenticate","callback","open","clearTimeout","_reconnectTimeoutRef","off","on","status","_onSCOpen","_onSCClose","event","res","_onSCEvent","reconnect","destroy","removeEventListener","oldState","oldSignedToken","stateChangeData","newState","_extractAuthTokenData","processPendingSubscriptions","decodeBase64","encodedString","from","toString","encodeBase64","decodedString","tokenParts","split","encodedTokenData","tokenData","JSON","e","getAuthToken","getSignedAuthToken","authenticate","authStatus","isAuthenticated","authError","hydrateError","name","_tryReconnect","exponent","timeout","initialTimeout","round","random","setTimeout","autoSubscribeOnConnect","_flushEmitBuffer","listeners","length","_suspendSubscriptions","channelName","hasOwnProperty","SUBSCRIBED","UNSUBSCRIBED","_abortAllPendingEventsDueToBadConnection","failureType","currentNode","head","nextNode","next","eventObject","detach","errorMessage","cid","cancelPendingResponse","openAbort","closeMessage","handler","apply","arguments","decode","encode","object","emitObject","_handleEventAckTimeout","eventNode","_emit","Item","cloneData","append","send","publish","pubData","_decorateChannelName","_triggerChannelSubscribe","subscriptionOptions","_triggerChannelSubscribeFail","meetsAuthRequirements","waitForAuth","_cancelPendingSubscribeCallback","_pendingSubscriptionCid","decoratedChannelName","indexOf","_trySubscribe","noTimeout","batch","subscribe","setOptions","_tryUnsubscribe","unsubscribe","currentChannel","destroyChannel","unwatch","subscriptions","includePending","subs","includeChannel","push","pendingChannels","i","sort","a","b","ap","priority","bp","forEach","watch","removeListener","removeAllListeners","watchers","module","exports"],"sources":["C:/Users/123/OneDrive/Desktop/git practice/git_destop/git-Check/testing/node_modules/socketcluster-client/lib/scclientsocket.js"],"sourcesContent":["var Emitter = require('component-emitter');\nvar SCChannel = require('sc-channel').SCChannel;\nvar Response = require('./response').Response;\nvar AuthEngine = require('./auth').AuthEngine;\nvar formatter = require('sc-formatter');\nvar SCTransport = require('./sctransport').SCTransport;\nvar querystring = require('querystring');\nvar LinkedList = require('linked-list');\nvar Buffer = require('buffer/').Buffer;\nvar clone = require('clone');\n\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidMessageError = scErrors.InvalidMessageError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar SocketProtocolError = scErrors.SocketProtocolError;\nvar TimeoutError = scErrors.TimeoutError;\nvar BadConnectionError = scErrors.BadConnectionError;\n\nvar isBrowser = typeof window !== 'undefined';\n\n\nvar SCClientSocket = function (opts) {\n  var self = this;\n\n  Emitter.call(this);\n\n  this.id = null;\n  this.state = this.CLOSED;\n  this.authState = this.UNAUTHENTICATED;\n  this.signedAuthToken = null;\n  this.authToken = null;\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  this.preparingPendingSubscriptions = false;\n  this.clientId = opts.clientId;\n\n  this.connectTimeout = opts.connectTimeout;\n  this.ackTimeout = opts.ackTimeout;\n  this.channelPrefix = opts.channelPrefix || null;\n  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;\n  this.authTokenName = opts.authTokenName;\n\n  // pingTimeout will be ackTimeout at the start, but it will\n  // be updated with values provided by the 'connect' event\n  this.pingTimeout = this.ackTimeout;\n  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;\n  this.active = true;\n\n  this._clientMap = opts.clientMap || {};\n\n  var maxTimeout = Math.pow(2, 31) - 1;\n\n  var verifyDuration = function (propertyName) {\n    if (self[propertyName] > maxTimeout) {\n      throw new InvalidArgumentsError('The ' + propertyName +\n        ' value provided exceeded the maximum amount allowed');\n    }\n  };\n\n  verifyDuration('connectTimeout');\n  verifyDuration('ackTimeout');\n\n  this._localEvents = {\n    'connect': 1,\n    'connectAbort': 1,\n    'close': 1,\n    'disconnect': 1,\n    'message': 1,\n    'error': 1,\n    'raw': 1,\n    'kickOut': 1,\n    'subscribe': 1,\n    'unsubscribe': 1,\n    'subscribeStateChange': 1,\n    'authStateChange': 1,\n    'authenticate': 1,\n    'deauthenticate': 1,\n    'removeAuthToken': 1,\n    'subscribeRequest': 1\n  };\n\n  this.connectAttempts = 0;\n\n  this._emitBuffer = new LinkedList();\n  this.channels = {};\n\n  this.options = opts;\n\n  this._cid = 1;\n\n  this.options.callIdGenerator = function () {\n    return self._cid++;\n  };\n\n  if (this.options.autoReconnect) {\n    if (this.options.autoReconnectOptions == null) {\n      this.options.autoReconnectOptions = {};\n    }\n\n    // Add properties to the this.options.autoReconnectOptions object.\n    // We assign the reference to a reconnectOptions variable to avoid repetition.\n    var reconnectOptions = this.options.autoReconnectOptions;\n    if (reconnectOptions.initialDelay == null) {\n      reconnectOptions.initialDelay = 10000;\n    }\n    if (reconnectOptions.randomness == null) {\n      reconnectOptions.randomness = 10000;\n    }\n    if (reconnectOptions.multiplier == null) {\n      reconnectOptions.multiplier = 1.5;\n    }\n    if (reconnectOptions.maxDelay == null) {\n      reconnectOptions.maxDelay = 60000;\n    }\n  }\n\n  if (this.options.subscriptionRetryOptions == null) {\n    this.options.subscriptionRetryOptions = {};\n  }\n\n  if (this.options.authEngine) {\n    this.auth = this.options.authEngine;\n  } else {\n    this.auth = new AuthEngine();\n  }\n\n  if (this.options.codecEngine) {\n    this.codec = this.options.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n\n  if (this.options.protocol) {\n    var protocolOptionError = new InvalidArgumentsError('The \"protocol\" option' +\n      ' does not affect socketcluster-client. If you want to utilize SSL/TLS' +\n      ' - use \"secure\" option instead');\n    this._onSCError(protocolOptionError);\n  }\n\n  this.options.path = this.options.path.replace(/\\/$/, '') + '/';\n\n  this.options.query = opts.query || {};\n  if (typeof this.options.query === 'string') {\n    this.options.query = querystring.parse(this.options.query);\n  }\n\n  this._channelEmitter = new Emitter();\n\n  this._unloadHandler = function () {\n    self.disconnect();\n  };\n\n  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {\n    global.addEventListener('beforeunload', this._unloadHandler, false);\n  }\n  this._clientMap[this.clientId] = this;\n\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\n\nSCClientSocket.prototype = Object.create(Emitter.prototype);\n\nSCClientSocket.CONNECTING = SCClientSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;\nSCClientSocket.OPEN = SCClientSocket.prototype.OPEN = SCTransport.prototype.OPEN;\nSCClientSocket.CLOSED = SCClientSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;\n\nSCClientSocket.AUTHENTICATED = SCClientSocket.prototype.AUTHENTICATED = 'authenticated';\nSCClientSocket.UNAUTHENTICATED = SCClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';\n\nSCClientSocket.PENDING = SCClientSocket.prototype.PENDING = 'pending';\n\nSCClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;\nSCClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;\n\nSCClientSocket.prototype._privateEventHandlerMap = {\n  '#publish': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);\n\n    if (isSubscribed) {\n      this._channelEmitter.emit(undecoratedChannelName, data.data);\n    }\n  },\n  '#kickOut': function (data) {\n    var undecoratedChannelName = this._undecorateChannelName(data.channel);\n    var channel = this.channels[undecoratedChannelName];\n    if (channel) {\n      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);\n      channel.emit('kickOut', data.message, undecoratedChannelName);\n      this._triggerChannelUnsubscribe(channel);\n    }\n  },\n  '#setAuthToken': function (data, response) {\n    var self = this;\n\n    if (data) {\n      var triggerAuthenticate = function (err) {\n        if (err) {\n          // This is a non-fatal error, we don't want to close the connection\n          // because of this but we do want to notify the server and throw an error\n          // on the client.\n          response.error(err);\n          self._onSCError(err);\n        } else {\n          self._changeToAuthenticatedState(data.token);\n          response.end();\n        }\n      };\n\n      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);\n    } else {\n      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));\n    }\n  },\n  '#removeAuthToken': function (data, response) {\n    var self = this;\n\n    this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n      if (err) {\n        // Non-fatal error - Do not close the connection\n        response.error(err);\n        self._onSCError(err);\n      } else {\n        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n        self._changeToUnauthenticatedStateAndClearTokens();\n        response.end();\n      }\n    });\n  },\n  '#disconnect': function (data) {\n    this.transport.close(data.code, data.data);\n  }\n};\n\nSCClientSocket.prototype.getState = function () {\n  return this.state;\n};\n\nSCClientSocket.prototype.getBytesReceived = function () {\n  return this.transport.getBytesReceived();\n};\n\nSCClientSocket.prototype.deauthenticate = function (callback) {\n  var self = this;\n\n  this.auth.removeToken(this.authTokenName, function (err, oldToken) {\n    if (err) {\n      // Non-fatal error - Do not close the connection\n      self._onSCError(err);\n    } else {\n      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);\n      if (self.state !== self.CLOSED) {\n        self.emit('#removeAuthToken');\n      }\n      self._changeToUnauthenticatedStateAndClearTokens();\n    }\n    callback && callback(err);\n  });\n};\n\nSCClientSocket.prototype.connect = SCClientSocket.prototype.open = function () {\n  var self = this;\n\n  if (!this.active) {\n    var error = new InvalidActionError('Cannot connect a destroyed client');\n    this._onSCError(error);\n    return;\n  }\n\n  if (this.state === this.CLOSED) {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n\n    this.state = this.CONNECTING;\n    Emitter.prototype.emit.call(this, 'connecting');\n\n    if (this.transport) {\n      this.transport.off();\n    }\n\n    this.transport = new SCTransport(this.auth, this.codec, this.options);\n\n    this.transport.on('open', function (status) {\n      self.state = self.OPEN;\n      self._onSCOpen(status);\n    });\n\n    this.transport.on('error', function (err) {\n      self._onSCError(err);\n    });\n\n    this.transport.on('close', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data);\n    });\n\n    this.transport.on('openAbort', function (code, data) {\n      self.state = self.CLOSED;\n      self._onSCClose(code, data, true);\n    });\n\n    this.transport.on('event', function (event, data, res) {\n      self._onSCEvent(event, data, res);\n    });\n  }\n};\n\nSCClientSocket.prototype.reconnect = function (code, data) {\n  this.disconnect(code, data);\n  this.connect();\n};\n\nSCClientSocket.prototype.disconnect = function (code, data) {\n  code = code || 1000;\n\n  if (typeof code !== 'number') {\n    throw new InvalidArgumentsError('If specified, the code argument must be a number');\n  }\n\n  if (this.state === this.OPEN || this.state === this.CONNECTING) {\n    this.transport.close(code, data);\n  } else {\n    this.pendingReconnect = false;\n    this.pendingReconnectTimeout = null;\n    clearTimeout(this._reconnectTimeoutRef);\n  }\n};\n\nSCClientSocket.prototype.destroy = function (code, data) {\n  if (isBrowser && global.removeEventListener) {\n    global.removeEventListener('beforeunload', this._unloadHandler, false);\n  }\n  this.active = false;\n  this.disconnect(code, data);\n  delete this._clientMap[this.clientId];\n};\n\nSCClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {\n  if (this.authState !== this.UNAUTHENTICATED) {\n    var oldState = this.authState;\n    var oldSignedToken = this.signedAuthToken;\n    this.authState = this.UNAUTHENTICATED;\n    this.signedAuthToken = null;\n    this.authToken = null;\n\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState\n    };\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'deauthenticate', oldSignedToken);\n  }\n};\n\nSCClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {\n  this.signedAuthToken = signedAuthToken;\n  this.authToken = this._extractAuthTokenData(signedAuthToken);\n\n  if (this.authState !== this.AUTHENTICATED) {\n    var oldState = this.authState;\n    this.authState = this.AUTHENTICATED;\n    var stateChangeData = {\n      oldState: oldState,\n      newState: this.authState,\n      signedAuthToken: signedAuthToken,\n      authToken: this.authToken\n    };\n    if (!this.preparingPendingSubscriptions) {\n      this.processPendingSubscriptions();\n    }\n\n    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);\n  }\n  Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);\n};\n\nSCClientSocket.prototype.decodeBase64 = function (encodedString) {\n  return Buffer.from(encodedString, 'base64').toString('utf8');\n};\n\nSCClientSocket.prototype.encodeBase64 = function (decodedString) {\n  return Buffer.from(decodedString, 'utf8').toString('base64');\n};\n\nSCClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {\n  var tokenParts = (signedAuthToken || '').split('.');\n  var encodedTokenData = tokenParts[1];\n  if (encodedTokenData != null) {\n    var tokenData = encodedTokenData;\n    try {\n      tokenData = this.decodeBase64(tokenData);\n      return JSON.parse(tokenData);\n    } catch (e) {\n      return tokenData;\n    }\n  }\n  return null;\n};\n\nSCClientSocket.prototype.getAuthToken = function () {\n  return this.authToken;\n};\n\nSCClientSocket.prototype.getSignedAuthToken = function () {\n  return this.signedAuthToken;\n};\n\n// Perform client-initiated authentication by providing an encrypted token string.\nSCClientSocket.prototype.authenticate = function (signedAuthToken, callback) {\n  var self = this;\n\n  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {\n    if (authStatus && authStatus.isAuthenticated != null) {\n      // If authStatus is correctly formatted (has an isAuthenticated property),\n      // then we will rehydrate the authError.\n      if (authStatus.authError) {\n        authStatus.authError = scErrors.hydrateError(authStatus.authError);\n      }\n    } else {\n      // Some errors like BadConnectionError and TimeoutError will not pass a valid\n      // authStatus object to the current function, so we need to create it ourselves.\n      authStatus = {\n        isAuthenticated: self.authState,\n        authError: null\n      };\n    }\n    if (err) {\n      if (err.name !== 'BadConnectionError' && err.name !== 'TimeoutError') {\n        // In case of a bad/closed connection or a timeout, we maintain the last\n        // known auth state since those errors don't mean that the token is invalid.\n\n        self._changeToUnauthenticatedStateAndClearTokens();\n      }\n      callback && callback(err, authStatus);\n    } else {\n      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {\n        if (err) {\n          self._onSCError(err);\n        }\n        if (authStatus.isAuthenticated) {\n          self._changeToAuthenticatedState(signedAuthToken);\n        } else {\n          self._changeToUnauthenticatedStateAndClearTokens();\n        }\n        callback && callback(err, authStatus);\n      });\n    }\n  });\n};\n\nSCClientSocket.prototype._tryReconnect = function (initialDelay) {\n  var self = this;\n\n  var exponent = this.connectAttempts++;\n  var reconnectOptions = this.options.autoReconnectOptions;\n  var timeout;\n\n  if (initialDelay == null || exponent > 0) {\n    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());\n\n    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));\n  } else {\n    timeout = initialDelay;\n  }\n\n  if (timeout > reconnectOptions.maxDelay) {\n    timeout = reconnectOptions.maxDelay;\n  }\n\n  clearTimeout(this._reconnectTimeoutRef);\n\n  this.pendingReconnect = true;\n  this.pendingReconnectTimeout = timeout;\n  this._reconnectTimeoutRef = setTimeout(function () {\n    self.connect();\n  }, timeout);\n};\n\nSCClientSocket.prototype._onSCOpen = function (status) {\n  var self = this;\n\n  this.preparingPendingSubscriptions = true;\n\n  if (status) {\n    this.id = status.id;\n    this.pingTimeout = status.pingTimeout;\n    this.transport.pingTimeout = this.pingTimeout;\n    if (status.isAuthenticated) {\n      this._changeToAuthenticatedState(status.authToken);\n    } else {\n      this._changeToUnauthenticatedStateAndClearTokens();\n    }\n  } else {\n    // This can happen if auth.loadToken (in sctransport.js) fails with\n    // an error - This means that the signedAuthToken cannot be loaded by\n    // the auth engine and therefore, we need to unauthenticate the client.\n    this._changeToUnauthenticatedStateAndClearTokens();\n  }\n\n  this.connectAttempts = 0;\n\n  if (this.options.autoSubscribeOnConnect) {\n    this.processPendingSubscriptions();\n  }\n\n  // If the user invokes the callback while in autoSubscribeOnConnect mode, it\n  // won't break anything.\n  Emitter.prototype.emit.call(this, 'connect', status, function () {\n    self.processPendingSubscriptions();\n  });\n\n  if (this.state === this.OPEN) {\n    this._flushEmitBuffer();\n  }\n};\n\nSCClientSocket.prototype._onSCError = function (err) {\n  var self = this;\n\n  // Throw error in different stack frame so that error handling\n  // cannot interfere with a reconnect action.\n  setTimeout(function () {\n    if (self.listeners('error').length < 1) {\n      throw err;\n    } else {\n      Emitter.prototype.emit.call(self, 'error', err);\n    }\n  }, 0);\n};\n\nSCClientSocket.prototype._suspendSubscriptions = function () {\n  var channel, newState;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n      if (channel.state === channel.SUBSCRIBED ||\n        channel.state === channel.PENDING) {\n\n        newState = channel.PENDING;\n      } else {\n        newState = channel.UNSUBSCRIBED;\n      }\n\n      this._triggerChannelUnsubscribe(channel, newState);\n    }\n  }\n};\n\nSCClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    clearTimeout(eventObject.timeout);\n    delete eventObject.timeout;\n    currentNode.detach();\n    currentNode = nextNode;\n\n    var callback = eventObject.callback;\n    if (callback) {\n      delete eventObject.callback;\n      var errorMessage = \"Event '\" + eventObject.event +\n        \"' was aborted due to a bad connection\";\n      var error = new BadConnectionError(errorMessage, failureType);\n      callback.call(eventObject, error, eventObject);\n    }\n    // Cleanup any pending response callback in the transport layer too.\n    if (eventObject.cid) {\n      this.transport.cancelPendingResponse(eventObject.cid);\n    }\n  }\n};\n\nSCClientSocket.prototype._onSCClose = function (code, data, openAbort) {\n  var self = this;\n\n  this.id = null;\n\n  if (this.transport) {\n    this.transport.off();\n  }\n  this.pendingReconnect = false;\n  this.pendingReconnectTimeout = null;\n  clearTimeout(this._reconnectTimeoutRef);\n\n  this._suspendSubscriptions();\n  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect');\n\n  // Try to reconnect\n  // on server ping timeout (4000)\n  // or on client pong timeout (4001)\n  // or on close without status (1005)\n  // or on handshake failure (4003)\n  // or on handshake rejection (4008)\n  // or on socket hung up (1006)\n  if (this.options.autoReconnect) {\n    if (code === 4000 || code === 4001 || code === 1005) {\n      // If there is a ping or pong timeout or socket closes without\n      // status, don't wait before trying to reconnect - These could happen\n      // if the client wakes up after a period of inactivity and in this case we\n      // want to re-establish the connection as soon as possible.\n      this._tryReconnect(0);\n\n      // Codes 4500 and above will be treated as permanent disconnects.\n      // Socket will not try to auto-reconnect.\n    } else if (code !== 1000 && code < 4500) {\n      this._tryReconnect();\n    }\n  }\n\n  if (openAbort) {\n    Emitter.prototype.emit.call(self, 'connectAbort', code, data);\n  } else {\n    Emitter.prototype.emit.call(self, 'disconnect', code, data);\n  }\n  Emitter.prototype.emit.call(self, 'close', code, data);\n\n  if (!SCClientSocket.ignoreStatuses[code]) {\n    var closeMessage;\n    if (data) {\n      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + data;\n    } else {\n      closeMessage = 'Socket connection closed with status code ' + code;\n    }\n    var err = new SocketProtocolError(SCClientSocket.errorStatuses[code] || closeMessage, code);\n    this._onSCError(err);\n  }\n};\n\nSCClientSocket.prototype._onSCEvent = function (event, data, res) {\n  var handler = this._privateEventHandlerMap[event];\n  if (handler) {\n    handler.call(this, data, res);\n  } else {\n    Emitter.prototype.emit.call(this, event, data, function () {\n      res && res.callback.apply(res, arguments);\n    });\n  }\n};\n\nSCClientSocket.prototype.decode = function (message) {\n  return this.transport.decode(message);\n};\n\nSCClientSocket.prototype.encode = function (object) {\n  return this.transport.encode(object);\n};\n\nSCClientSocket.prototype._flushEmitBuffer = function () {\n  var currentNode = this._emitBuffer.head;\n  var nextNode;\n\n  while (currentNode) {\n    nextNode = currentNode.next;\n    var eventObject = currentNode.data;\n    currentNode.detach();\n    this.transport.emitObject(eventObject);\n    currentNode = nextNode;\n  }\n};\n\nSCClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {\n  if (eventNode) {\n    eventNode.detach();\n  }\n  delete eventObject.timeout;\n\n  var callback = eventObject.callback;\n  if (callback) {\n    delete eventObject.callback;\n    var error = new TimeoutError(\"Event response for '\" + eventObject.event + \"' timed out\");\n    callback.call(eventObject, error, eventObject);\n  }\n  // Cleanup any pending response callback in the transport layer too.\n  if (eventObject.cid) {\n    this.transport.cancelPendingResponse(eventObject.cid);\n  }\n};\n\nSCClientSocket.prototype._emit = function (event, data, callback) {\n  var self = this;\n\n  if (this.state === this.CLOSED) {\n    this.connect();\n  }\n  var eventObject = {\n    event: event,\n    callback: callback\n  };\n\n  var eventNode = new LinkedList.Item();\n\n  if (this.options.cloneData) {\n    eventObject.data = clone(data);\n  } else {\n    eventObject.data = data;\n  }\n  eventNode.data = eventObject;\n\n  eventObject.timeout = setTimeout(function () {\n    self._handleEventAckTimeout(eventObject, eventNode);\n  }, this.ackTimeout);\n\n  this._emitBuffer.append(eventNode);\n  if (this.state === this.OPEN) {\n    this._flushEmitBuffer();\n  }\n};\n\nSCClientSocket.prototype.send = function (data) {\n  this.transport.send(data);\n};\n\nSCClientSocket.prototype.emit = function (event, data, callback) {\n  if (this._localEvents[event] == null) {\n    this._emit(event, data, callback);\n  } else if (event === 'error') {\n    Emitter.prototype.emit.call(this, event, data);\n  } else {\n    var error = new InvalidActionError('The \"' + event + '\" event is reserved and cannot be emitted on a client socket');\n    this._onSCError(error);\n  }\n};\n\nSCClientSocket.prototype.publish = function (channelName, data, callback) {\n  var pubData = {\n    channel: this._decorateChannelName(channelName),\n    data: data\n  };\n  this.emit('#publish', pubData, callback);\n};\n\nSCClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {\n  var channelName = channel.name;\n\n  if (channel.state !== channel.SUBSCRIBED) {\n    var oldState = channel.state;\n    channel.state = channel.SUBSCRIBED;\n\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state,\n      subscriptionOptions: subscriptionOptions\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('subscribe', channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);\n  }\n};\n\nSCClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {\n  var channelName = channel.name;\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\n\n  if (channel.state !== channel.UNSUBSCRIBED && meetsAuthRequirements) {\n    channel.state = channel.UNSUBSCRIBED;\n\n    channel.emit('subscribeFail', err, channelName, subscriptionOptions);\n    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);\n  }\n};\n\n// Cancel any pending subscribe callback\nSCClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {\n  if (channel._pendingSubscriptionCid != null) {\n    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);\n    delete channel._pendingSubscriptionCid;\n  }\n};\n\nSCClientSocket.prototype._decorateChannelName = function (channelName) {\n  if (this.channelPrefix) {\n    channelName = this.channelPrefix + channelName;\n  }\n  return channelName;\n};\n\nSCClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {\n  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) === 0) {\n    return decoratedChannelName.replace(this.channelPrefix, '');\n  }\n  return decoratedChannelName;\n};\n\nSCClientSocket.prototype._trySubscribe = function (channel) {\n  var self = this;\n\n  var meetsAuthRequirements = !channel.waitForAuth || this.authState === this.AUTHENTICATED;\n\n  // We can only ever have one pending subscribe action at any given time on a channel\n  if (this.state === this.OPEN && !this.preparingPendingSubscriptions &&\n    channel._pendingSubscriptionCid == null && meetsAuthRequirements) {\n\n    var options = {\n      noTimeout: true\n    };\n\n    var subscriptionOptions = {\n      channel: this._decorateChannelName(channel.name)\n    };\n    if (channel.waitForAuth) {\n      options.waitForAuth = true;\n      subscriptionOptions.waitForAuth = options.waitForAuth;\n    }\n    if (channel.data) {\n      subscriptionOptions.data = channel.data;\n    }\n    if (channel.batch) {\n      options.batch = true;\n      subscriptionOptions.batch = true;\n    }\n\n    channel._pendingSubscriptionCid = this.transport.emit(\n      '#subscribe', subscriptionOptions, options,\n      function (err) {\n        delete channel._pendingSubscriptionCid;\n        if (err) {\n          self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);\n        } else {\n          self._triggerChannelSubscribe(channel, subscriptionOptions);\n        }\n      }\n    );\n    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);\n  }\n};\n\nSCClientSocket.prototype.subscribe = function (channelName, options) {\n  var channel = this.channels[channelName];\n\n  if (!channel) {\n    channel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = channel;\n  } else if (options) {\n    channel.setOptions(options);\n  }\n\n  if (channel.state === channel.UNSUBSCRIBED) {\n    channel.state = channel.PENDING;\n    this._trySubscribe(channel);\n  }\n\n  return channel;\n};\n\nSCClientSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {\n  var channelName = channel.name;\n  var oldState = channel.state;\n\n  if (newState) {\n    channel.state = newState;\n  } else {\n    channel.state = channel.UNSUBSCRIBED;\n  }\n  this._cancelPendingSubscribeCallback(channel);\n\n  if (oldState === channel.SUBSCRIBED) {\n    var stateChangeData = {\n      channel: channelName,\n      oldState: oldState,\n      newState: channel.state\n    };\n    channel.emit('subscribeStateChange', stateChangeData);\n    channel.emit('unsubscribe', channelName);\n    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);\n    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);\n  }\n};\n\nSCClientSocket.prototype._tryUnsubscribe = function (channel) {\n  var self = this;\n\n  if (this.state === this.OPEN) {\n    var options = {\n      noTimeout: true\n    };\n    if (channel.batch) {\n      options.batch = true;\n    }\n    // If there is a pending subscribe action, cancel the callback\n    this._cancelPendingSubscribeCallback(channel);\n\n    // This operation cannot fail because the TCP protocol guarantees delivery\n    // so long as the connection remains open. If the connection closes,\n    // the server will automatically unsubscribe the client and thus complete\n    // the operation on the server side.\n    var decoratedChannelName = this._decorateChannelName(channel.name);\n    this.transport.emit('#unsubscribe', decoratedChannelName, options);\n  }\n};\n\nSCClientSocket.prototype.unsubscribe = function (channelName) {\n  var channel = this.channels[channelName];\n\n  if (channel) {\n    if (channel.state !== channel.UNSUBSCRIBED) {\n      this._triggerChannelUnsubscribe(channel);\n      this._tryUnsubscribe(channel);\n    }\n  }\n};\n\nSCClientSocket.prototype.channel = function (channelName, options) {\n  var currentChannel = this.channels[channelName];\n\n  if (!currentChannel) {\n    currentChannel = new SCChannel(channelName, this, options);\n    this.channels[channelName] = currentChannel;\n  }\n  return currentChannel;\n};\n\nSCClientSocket.prototype.destroyChannel = function (channelName) {\n  var channel = this.channels[channelName];\n\n  if (channel) {\n    channel.unwatch();\n    channel.unsubscribe();\n    delete this.channels[channelName];\n  }\n};\n\nSCClientSocket.prototype.subscriptions = function (includePending) {\n  var subs = [];\n  var channel, includeChannel;\n  for (var channelName in this.channels) {\n    if (this.channels.hasOwnProperty(channelName)) {\n      channel = this.channels[channelName];\n\n      if (includePending) {\n        includeChannel = channel && (channel.state === channel.SUBSCRIBED ||\n          channel.state === channel.PENDING);\n      } else {\n        includeChannel = channel && channel.state === channel.SUBSCRIBED;\n      }\n\n      if (includeChannel) {\n        subs.push(channelName);\n      }\n    }\n  }\n  return subs;\n};\n\nSCClientSocket.prototype.isSubscribed = function (channelName, includePending) {\n  var channel = this.channels[channelName];\n  if (includePending) {\n    return !!channel && (channel.state === channel.SUBSCRIBED ||\n      channel.state === channel.PENDING);\n  }\n  return !!channel && channel.state === channel.SUBSCRIBED;\n};\n\nSCClientSocket.prototype.processPendingSubscriptions = function () {\n  var self = this;\n\n  this.preparingPendingSubscriptions = false;\n\n  var pendingChannels = [];\n\n  for (var i in this.channels) {\n    if (this.channels.hasOwnProperty(i)) {\n      var channel = this.channels[i];\n      if (channel.state === channel.PENDING) {\n        pendingChannels.push(channel);\n      }\n    }\n  }\n\n  pendingChannels.sort(function (a, b) {\n    var ap = a.priority || 0;\n    var bp = b.priority || 0;\n    if (ap > bp) {\n      return -1;\n    }\n    if (ap < bp) {\n      return 1;\n    }\n    return 0;\n  });\n\n  pendingChannels.forEach(function (channel) {\n    self._trySubscribe(channel);\n  });\n};\n\nSCClientSocket.prototype.watch = function (channelName, handler) {\n  if (typeof handler !== 'function') {\n    throw new InvalidArgumentsError('No handler function was provided');\n  }\n  this._channelEmitter.on(channelName, handler);\n};\n\nSCClientSocket.prototype.unwatch = function (channelName, handler) {\n  if (handler) {\n    this._channelEmitter.removeListener(channelName, handler);\n  } else {\n    this._channelEmitter.removeAllListeners(channelName);\n  }\n};\n\nSCClientSocket.prototype.watchers = function (channelName) {\n  return this._channelEmitter.listeners(channelName);\n};\n\nmodule.exports = SCClientSocket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}