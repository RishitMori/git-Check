{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports[\"default\"] = instrument;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = void 0;\nvar _difference = _interopRequireDefault(require(\"lodash/difference\"));\nvar _union = _interopRequireDefault(require(\"lodash/union\"));\nvar _isPlainObject = _interopRequireDefault(require(\"lodash/isPlainObject\"));\nvar _symbolObservable = _interopRequireDefault(require(\"symbol-observable\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nvar ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nexports.ActionTypes = ActionTypes;\nvar isChrome = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n\n/**\n * Action creators to change the History state.\n */\nvar ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace) {\n    if (!(0, _isPlainObject[\"default\"])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n    var stack;\n    if (trace) {\n      var extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || traceLimit && Error.stackTraceLimit > traceLimit) {\n          if (stack != null) {\n            var frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames.slice(0, traceLimit + extraFrames + (frames[0].startsWith('Error') ? 1 : 0)).join('\\n');\n            }\n          }\n        }\n      }\n    }\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nexports.ActionCreators = ActionCreators;\nvar INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nexports.INIT_ACTION = INIT_ACTION;\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var _actionId = stagedActionIds[i];\n    var _action = actionsById[_actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(_actionId) > -1;\n    var entry = void 0;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, _action, previousState, shouldCatchErrors);\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\nfunction liftAction(action, trace, traceLimit,\n// eslint-disable-next-line @typescript-eslint/ban-types\ntoExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\nfunction isArray(nextLiftedState) {\n  return Array.isArray(nextLiftedState);\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n      monitorState = _ref.monitorState,\n      actionsById = _ref.actionsById,\n      nextActionId = _ref.nextActionId,\n      stagedActionIds = _ref.stagedActionIds,\n      skippedActionIds = _ref.skippedActionIds,\n      committedState = _ref.committedState,\n      currentStateIndex = _ref.currentStateIndex,\n      computedStates = _ref.computedStates,\n      isLocked = _ref.isLocked,\n      isPaused = _ref.isPaused;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _objectSpread({}, actionsById);\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function computePausedAction(shouldInit) {\n      var computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n        nextActionId++;\n      }\n      return {\n        monitorState: monitorState,\n        actionsById: _objectSpread(_objectSpread({}, actionsById), {}, _defineProperty({}, nextActionId - 1, liftAction({\n          type: options.pauseActionType\n        }))),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(_toConsumableArray(computedStates.slice(0, stagedActionIds.length - 1)), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n      minInvalidatedStateIndex = 0;\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            var _actionId2 = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[_actionId2] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId3 = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId3);\n            if (index === -1) {\n              skippedActionIds = [_actionId3].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId3;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId3);\n            break;\n          }\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n              end = liftedAction.end,\n              active = liftedAction.active;\n            var actionIds = [];\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n            if (active) {\n              skippedActionIds = (0, _difference[\"default\"])(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union[\"default\"])(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference[\"default\"])(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId4 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId4); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n            var diff = idx - newIdx;\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1)));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds.slice(0, idx)), _toConsumableArray(stagedActionIds.slice(idx + 1, newIdx)), [_actionId4], _toConsumableArray(stagedActionIds.slice(newIdx)));\n              minInvalidatedStateIndex = idx;\n            }\n            break;\n          }\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              // Completely replace everything.\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n            break;\n          }\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n    currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n\n/**\n * Provides an app's view into the lifted store.\n */\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var lastDefinedState;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n  return _objectSpread(_objectSpread({}, liftedStore), {}, _defineProperty({\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _symbolObservable[\"default\"], function () {\n    return _objectSpread(_objectSpread({}, liftedStore[_symbolObservable[\"default\"]]()), {}, _defineProperty({\n      subscribe: function subscribe(observer) {\n        if (_typeof(observer) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _symbolObservable[\"default\"], function () {\n      return this;\n    }));\n  }));\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n  return function (createStore) {\n    return function (reducer, initialState) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r[\"default\"] === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n          throw new Error('Expected the reducer to be a function.');\n        }\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n      var liftedStore = createStore(liftReducer(reducer));\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}","map":{"version":3,"names":["_difference","_interopRequireDefault","require","_union","_isPlainObject","_symbolObservable","ActionTypes","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","_typeof","chrome","process","type","isChromeOrNode","release","name","ActionCreators","performAction","action","trace","traceLimit","toExcludeFromTrace","Error","stack","extraFrames","error","prevStackTraceLimit","captureStackTrace","stackTraceLimit","frames","split","length","slice","startsWith","join","timestamp","Date","now","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","start","end","active","arguments","undefined","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","INIT_ACTION","computeWithTryCatch","reducer","state","nextState","nextError","err","toString","setTimeout","console","computeNextEntry","shouldCatchErrors","recomputeStates","computedStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","nextComputedStates","i","_actionId","_action","previousEntry","previousState","shouldSkip","indexOf","entry","push","liftAction","isArray","Array","liftReducerWith","initialCommittedState","monitorReducer","options","initialLiftedState","monitorState","nextActionId","currentStateIndex","isLocked","shouldStartLocked","isPaused","shouldRecordChanges","liftedState","liftedAction","_ref","_objectSpread","commitExcessActions","n","excess","idsToDelete","filter","concat","_toConsumableArray","computePausedAction","shouldInit","computedState","pauseActionType","_defineProperty","maxAge","test","shouldHotReload","Infinity","_actionId2","_actionId3","actionIds","_index","Math","min","_actionId4","idx","newIdx","count","diff","preloadedState","forEach","shouldIncludeCallstack","_liftedAction$nextLif","unliftState","unliftStore","liftedStore","liftReducer","lastDefinedState","getState","dispatch","replaceReducer","nextReducer","subscribe","observer","TypeError","observeState","next","unsubscribe","instrument","createStore","initialState","r"],"sources":["C:\\Users\\123\\OneDrive\\Desktop\\git practice\\git_destop\\git-Check\\testing\\node_modules\\redux-devtools-instrument\\src\\instrument.ts"],"sourcesContent":["import difference from 'lodash/difference';\nimport union from 'lodash/union';\nimport isPlainObject from 'lodash/isPlainObject';\nimport $$observable from 'symbol-observable';\nimport {\n  Action,\n  Observable,\n  PreloadedState,\n  Reducer,\n  Store,\n  StoreEnhancer,\n  StoreEnhancerStoreCreator,\n} from 'redux';\n\nexport const ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING',\n} as const;\n\nconst isChrome =\n  typeof window === 'object' &&\n  (typeof (window as typeof window & { chrome: unknown }).chrome !==\n    'undefined' ||\n    (typeof window.process !== 'undefined' &&\n      (window.process as typeof window.process & { type: unknown }).type ===\n        'renderer'));\n\nconst isChromeOrNode =\n  isChrome ||\n  (typeof process !== 'undefined' &&\n    process.release &&\n    process.release.name === 'node');\n\nexport interface PerformAction<A extends Action<unknown>> {\n  type: typeof ActionTypes.PERFORM_ACTION;\n  action: A;\n  timestamp: number;\n  stack: string | undefined;\n}\n\ninterface ResetAction {\n  type: typeof ActionTypes.RESET;\n  timestamp: number;\n}\n\ninterface RollbackAction {\n  type: typeof ActionTypes.ROLLBACK;\n  timestamp: number;\n}\n\ninterface CommitAction {\n  type: typeof ActionTypes.COMMIT;\n  timestamp: number;\n}\n\ninterface SweepAction {\n  type: typeof ActionTypes.SWEEP;\n}\n\ninterface ToggleAction {\n  type: typeof ActionTypes.TOGGLE_ACTION;\n  id: number;\n}\n\ninterface SetActionsActiveAction {\n  type: typeof ActionTypes.SET_ACTIONS_ACTIVE;\n  start: number;\n  end: number;\n  active: boolean;\n}\n\ninterface ReorderAction {\n  type: typeof ActionTypes.REORDER_ACTION;\n  actionId: number;\n  beforeActionId: number;\n}\n\ninterface JumpToStateAction {\n  type: typeof ActionTypes.JUMP_TO_STATE;\n  index: number;\n}\n\ninterface JumpToActionAction {\n  type: typeof ActionTypes.JUMP_TO_ACTION;\n  actionId: number;\n}\n\ninterface ImportStateAction<S, A extends Action<unknown>, MonitorState> {\n  type: typeof ActionTypes.IMPORT_STATE;\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[];\n  preloadedState?: S;\n  noRecompute: boolean | undefined;\n}\n\ninterface LockChangesAction {\n  type: typeof ActionTypes.LOCK_CHANGES;\n  status: boolean;\n}\n\ninterface PauseRecordingAction {\n  type: typeof ActionTypes.PAUSE_RECORDING;\n  status: boolean;\n}\n\nexport type LiftedAction<S, A extends Action<unknown>, MonitorState> =\n  | PerformAction<A>\n  | ResetAction\n  | RollbackAction\n  | CommitAction\n  | SweepAction\n  | ToggleAction\n  | SetActionsActiveAction\n  | ReorderAction\n  | JumpToStateAction\n  | JumpToActionAction\n  | ImportStateAction<S, A, MonitorState>\n  | LockChangesAction\n  | PauseRecordingAction;\n\n/**\n * Action creators to change the History state.\n */\nexport const ActionCreators = {\n  performAction<A extends Action<unknown>>(\n    action: A,\n    trace?: ((action: A) => string | undefined) | boolean,\n    traceLimit?: number,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    toExcludeFromTrace?: Function\n  ) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' +\n          'Use custom middleware for async actions.'\n      );\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n\n    let stack;\n    if (trace) {\n      let extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        const error = Error();\n        let prevStackTraceLimit;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (traceLimit && Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (\n          extraFrames ||\n          typeof Error.stackTraceLimit !== 'number' ||\n          (traceLimit && Error.stackTraceLimit > traceLimit)\n        ) {\n          if (stack != null) {\n            const frames = stack.split('\\n');\n            if (traceLimit && frames.length > traceLimit) {\n              stack = frames\n                .slice(\n                  0,\n                  traceLimit +\n                    extraFrames +\n                    (frames[0].startsWith('Error') ? 1 : 0)\n                )\n                .join('\\n');\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action,\n      timestamp: Date.now(),\n      stack,\n    };\n  },\n\n  reset(): ResetAction {\n    return { type: ActionTypes.RESET, timestamp: Date.now() };\n  },\n\n  rollback(): RollbackAction {\n    return { type: ActionTypes.ROLLBACK, timestamp: Date.now() };\n  },\n\n  commit(): CommitAction {\n    return { type: ActionTypes.COMMIT, timestamp: Date.now() };\n  },\n\n  sweep(): SweepAction {\n    return { type: ActionTypes.SWEEP };\n  },\n\n  toggleAction(id: number): ToggleAction {\n    return { type: ActionTypes.TOGGLE_ACTION, id };\n  },\n\n  setActionsActive(\n    start: number,\n    end: number,\n    active = true\n  ): SetActionsActiveAction {\n    return { type: ActionTypes.SET_ACTIONS_ACTIVE, start, end, active };\n  },\n\n  reorderAction(actionId: number, beforeActionId: number): ReorderAction {\n    return { type: ActionTypes.REORDER_ACTION, actionId, beforeActionId };\n  },\n\n  jumpToState(index: number): JumpToStateAction {\n    return { type: ActionTypes.JUMP_TO_STATE, index };\n  },\n\n  jumpToAction(actionId: number): JumpToActionAction {\n    return { type: ActionTypes.JUMP_TO_ACTION, actionId };\n  },\n\n  importState<S, A extends Action<unknown>, MonitorState = null>(\n    nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[],\n    noRecompute?: boolean\n  ): ImportStateAction<S, A, MonitorState> {\n    return { type: ActionTypes.IMPORT_STATE, nextLiftedState, noRecompute };\n  },\n\n  lockChanges(status: boolean): LockChangesAction {\n    return { type: ActionTypes.LOCK_CHANGES, status };\n  },\n\n  pauseRecording(status: boolean): PauseRecordingAction {\n    return { type: ActionTypes.PAUSE_RECORDING, status };\n  },\n};\n\nexport const INIT_ACTION = { type: '@@INIT' };\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S\n) {\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(() => {\n        throw err;\n      });\n    } else {\n      console.error(err); // eslint-disable-line no-console\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry<S, A extends Action<unknown>>(\n  reducer: Reducer<S, A>,\n  action: A,\n  state: S,\n  shouldCatchErrors: boolean | undefined\n) {\n  if (!shouldCatchErrors) {\n    return { state: reducer(state, action) };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates<S, A extends Action<unknown>>(\n  computedStates: { state: S; error?: string }[],\n  minInvalidatedStateIndex: number,\n  reducer: Reducer<S, A>,\n  committedState: S,\n  actionsById: { [actionId: number]: PerformAction<A> },\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  shouldCatchErrors: boolean | undefined\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    !computedStates ||\n    minInvalidatedStateIndex === -1 ||\n    (minInvalidatedStateIndex >= computedStates.length &&\n      computedStates.length === stagedActionIds.length)\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    let entry;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain',\n        };\n      } else {\n        entry = computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          shouldCatchErrors\n        );\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction<A extends Action<unknown>>(\n  action: A,\n  trace?: ((action: A) => string | undefined) | boolean,\n  traceLimit?: number,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  toExcludeFromTrace?: Function\n) {\n  return ActionCreators.performAction(\n    action,\n    trace,\n    traceLimit,\n    toExcludeFromTrace\n  );\n}\n\nfunction isArray<S, A extends Action<unknown>, MonitorState>(\n  nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[]\n): nextLiftedState is readonly A[] {\n  return Array.isArray(nextLiftedState);\n}\n\nexport interface LiftedState<S, A extends Action<unknown>, MonitorState> {\n  monitorState: MonitorState;\n  nextActionId: number;\n  actionsById: { [actionId: number]: PerformAction<A> };\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: S;\n  currentStateIndex: number;\n  computedStates: { state: S; error?: string }[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n>(\n  reducer: Reducer<S, A>,\n  initialCommittedState: PreloadedState<S> | undefined,\n  monitorReducer: Reducer<MonitorState, MonitorAction>,\n  options: Options<S, A, MonitorState, MonitorAction>\n): Reducer<LiftedState<S, A, MonitorState>, LiftedAction<S, A, MonitorState>> {\n  const initialLiftedState: LiftedState<S, A, MonitorState> = {\n    monitorState: monitorReducer(undefined, {} as MonitorAction),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION as A) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState as S,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false,\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    liftedState: LiftedState<S, A, MonitorState> | undefined,\n    liftedAction: LiftedAction<S, A, MonitorState>\n  ): LiftedState<S, A, MonitorState> => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = { ...actionsById };\n    }\n\n    function commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        (id) => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(\n      shouldInit?: boolean\n    ): LiftedState<S, A, MonitorState> {\n      let computedState;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(\n          monitorState,\n          liftedAction as MonitorAction\n        );\n      } else {\n        computedState = computeNextEntry(\n          reducer,\n          (liftedAction as PerformAction<A>).action,\n          computedStates[currentStateIndex].state,\n          false\n        );\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState,\n          actionsById: { 0: liftAction(INIT_ACTION as A) },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked,\n          isPaused: true,\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [...stagedActionIds, nextActionId];\n        nextActionId++;\n      }\n      return {\n        monitorState,\n        actionsById: {\n          ...actionsById,\n          [nextActionId - 1]: liftAction({\n            type: options.pauseActionType,\n          } as A),\n        },\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates: [\n          ...computedStates.slice(0, stagedActionIds.length - 1),\n          computedState,\n        ],\n        isLocked,\n        isPaused: true,\n      };\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    let maxAge = options.maxAge;\n    if (typeof maxAge === 'function')\n      maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = { 0: liftAction(INIT_ACTION as A) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState =\n          computedStates.length === 0\n            ? (initialCommittedState as S)\n            : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates<S, A>(\n          computedStates,\n          minInvalidatedStateIndex,\n          reducer,\n          committedState,\n          actionsById,\n          stagedActionIds,\n          skippedActionIds,\n          options.shouldCatchErrors\n        );\n\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION: {\n          if (isLocked) return liftedState || initialLiftedState;\n          if (isPaused) return computePausedAction();\n\n          // Auto-commit as new actions come in.\n          if (maxAge && stagedActionIds.length >= maxAge) {\n            commitExcessActions(stagedActionIds.length - maxAge + 1);\n          }\n\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n        case ActionTypes.RESET: {\n          // Get back to the state the store was created with.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState as S;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.COMMIT: {\n          // Consider the last committed state the new starting point.\n          // Squash any staged actions into a single committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.ROLLBACK: {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case ActionTypes.TOGGLE_ACTION: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { id: actionId } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n        case ActionTypes.SET_ACTIONS_ACTIVE: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { start, end, active } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = union(skippedActionIds, actionIds);\n          }\n\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n        case ActionTypes.JUMP_TO_STATE: {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.JUMP_TO_ACTION: {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.SWEEP: {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(\n            currentStateIndex,\n            stagedActionIds.length - 1\n          );\n          break;\n        }\n        case ActionTypes.REORDER_ACTION: {\n          // Recompute actions in a new order.\n          const actionId = liftedAction.actionId;\n          const idx = stagedActionIds.indexOf(actionId);\n          // do nothing in case the action is already removed or trying to move the first action\n          if (idx < 1) break;\n          const beforeActionId = liftedAction.beforeActionId;\n          let newIdx = stagedActionIds.indexOf(beforeActionId);\n          if (newIdx < 1) {\n            // move to the beginning or to the end\n            const count = stagedActionIds.length;\n            newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n          }\n          const diff = idx - newIdx;\n\n          if (diff > 0) {\n            // move left\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx, idx),\n              ...stagedActionIds.slice(idx + 1),\n            ];\n            minInvalidatedStateIndex = newIdx;\n          } else if (diff < 0) {\n            // move right\n            stagedActionIds = [\n              ...stagedActionIds.slice(0, idx),\n              ...stagedActionIds.slice(idx + 1, newIdx),\n              actionId,\n              ...stagedActionIds.slice(newIdx),\n            ];\n            minInvalidatedStateIndex = idx;\n          }\n          break;\n        }\n        case ActionTypes.IMPORT_STATE: {\n          if (isArray(liftedAction.nextLiftedState)) {\n            // recompute array of actions\n            actionsById = { 0: liftAction(INIT_ACTION as A) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = liftedAction.nextLiftedState.length;\n            computedStates = [];\n            committedState = liftedAction.preloadedState as S;\n            minInvalidatedStateIndex = 0;\n            // iterate through actions\n            liftedAction.nextLiftedState.forEach((action) => {\n              actionsById[nextActionId] = liftAction(\n                action,\n                options.trace || options.shouldIncludeCallstack\n              );\n              stagedActionIds.push(nextActionId);\n              nextActionId++;\n            });\n          } else {\n            // Completely replace everything.\n            ({\n              monitorState,\n              actionsById,\n              nextActionId,\n              stagedActionIds,\n              skippedActionIds,\n              committedState,\n              currentStateIndex,\n              computedStates,\n            } = liftedAction.nextLiftedState);\n\n            if (liftedAction.noRecompute) {\n              minInvalidatedStateIndex = Infinity;\n            }\n          }\n\n          break;\n        }\n        case ActionTypes.LOCK_CHANGES: {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case ActionTypes.PAUSE_RECORDING: {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            return computePausedAction(true);\n          }\n          // Commit when unpausing\n          actionsById = { 0: liftAction(INIT_ACTION as A) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = computedStates[currentStateIndex].state;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        default: {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds,\n      options.shouldCatchErrors\n    );\n    monitorState = monitorReducer(monitorState, liftedAction as MonitorAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  NextStateExt\n>(\n  liftedState: LiftedState<S, A, MonitorState> & NextStateExt\n): S & NextStateExt {\n  const { computedStates, currentStateIndex } = liftedState;\n  const { state } = computedStates[currentStateIndex];\n  return state as S & NextStateExt;\n}\n\nexport type LiftedReducer<S, A extends Action<unknown>, MonitorState> = Reducer<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type LiftedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  LiftedState<S, A, MonitorState>,\n  LiftedAction<S, A, MonitorState>\n>;\n\nexport type InstrumentExt<S, A extends Action<unknown>, MonitorState> = {\n  liftedStore: LiftedStore<S, A, MonitorState>;\n};\n\nexport type EnhancedStore<S, A extends Action<unknown>, MonitorState> = Store<\n  S,\n  A\n> &\n  InstrumentExt<S, A, MonitorState>;\n\n/**\n * Provides an app's view into the lifted store.\n */\nexport function unliftStore<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>,\n  NextExt,\n  NextStateExt\n>(\n  liftedStore: Store<\n    LiftedState<S, A, MonitorState> & NextStateExt,\n    LiftedAction<S, A, MonitorState>\n  > &\n    NextExt,\n  liftReducer: (r: Reducer<S, A>) => LiftedReducer<S, A, MonitorState>,\n  options: Options<S, A, MonitorState, MonitorAction>\n) {\n  let lastDefinedState: S & NextStateExt;\n  const trace = options.trace || options.shouldIncludeCallstack;\n  const traceLimit = options.traceLimit || 10;\n\n  function getState(): S & NextStateExt {\n    const state = unliftState<S, A, MonitorState, NextStateExt>(\n      liftedStore.getState()\n    );\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n\n  function dispatch<T extends A>(action: T): T {\n    liftedStore.dispatch(liftAction<A>(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return ({\n    ...liftedStore,\n\n    liftedStore,\n\n    dispatch,\n\n    getState,\n\n    replaceReducer(nextReducer: Reducer<S & NextStateExt, A>) {\n      liftedStore.replaceReducer(\n        (liftReducer(\n          (nextReducer as unknown) as Reducer<S, A>\n        ) as unknown) as Reducer<\n          LiftedState<S, A, MonitorState> & NextStateExt,\n          LiftedAction<S, A, MonitorState>\n        >\n      );\n    },\n\n    [$$observable](): Observable<S> {\n      return {\n        ...(liftedStore as any)[$$observable](),\n        subscribe(observer) {\n          if (typeof observer !== 'object') {\n            throw new TypeError('Expected the observer to be an object.');\n          }\n\n          function observeState() {\n            if (observer.next) {\n              observer.next(getState());\n            }\n          }\n\n          observeState();\n          const unsubscribe = liftedStore.subscribe(observeState);\n          return { unsubscribe };\n        },\n\n        [$$observable]() {\n          return this;\n        },\n      };\n    },\n  } as unknown) as Store<S & NextStateExt, A> &\n    NextExt & {\n      liftedStore: Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      >;\n    };\n}\n\nexport interface Options<\n  S,\n  A extends Action<unknown>,\n  MonitorState,\n  MonitorAction extends Action<unknown>\n> {\n  maxAge?:\n    | number\n    | ((\n        currentLiftedAction: LiftedAction<S, A, MonitorState>,\n        previousLiftedState: LiftedState<S, A, MonitorState> | undefined\n      ) => number);\n  shouldCatchErrors?: boolean;\n  shouldRecordChanges?: boolean;\n  pauseActionType?: unknown;\n  shouldStartLocked?: boolean;\n  shouldHotReload?: boolean;\n  trace?: boolean | ((action: A) => string | undefined);\n  traceLimit?: number;\n  shouldIncludeCallstack?: boolean;\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nexport default function instrument<\n  OptionsS,\n  OptionsA extends Action<unknown>,\n  MonitorState = null,\n  MonitorAction extends Action<unknown> = never\n>(\n  monitorReducer: Reducer<MonitorState, MonitorAction> = ((() =>\n    null) as unknown) as Reducer<MonitorState, MonitorAction>,\n  options: Options<OptionsS, OptionsA, MonitorState, MonitorAction> = {}\n): StoreEnhancer<InstrumentExt<any, any, MonitorState>> {\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error(\n      'DevTools.instrument({ maxAge }) option, if specified, ' +\n        'may not be less than 2.'\n    );\n  }\n\n  return <NextExt, NextStateExt>(\n    createStore: StoreEnhancerStoreCreator<NextExt, NextStateExt>\n  ) => <S, A extends Action<unknown>>(\n    reducer: Reducer<S, A>,\n    initialState?: PreloadedState<S>\n  ) => {\n    function liftReducer(r: Reducer<S, A>) {\n      if (typeof r !== 'function') {\n        if (r && typeof (r as { default: unknown }).default === 'function') {\n          throw new Error(\n            'Expected the reducer to be a function. ' +\n              'Instead got an object with a \"default\" field. ' +\n              'Did you pass a module instead of the default export? ' +\n              'Try passing require(...).default instead.'\n          );\n        }\n        throw new Error('Expected the reducer to be a function.');\n      }\n      return liftReducerWith<S, A, MonitorState, MonitorAction>(\n        r,\n        initialState,\n        monitorReducer,\n        (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n      );\n    }\n\n    const liftedStore = createStore(liftReducer(reducer));\n    if (\n      (liftedStore as Store<\n        LiftedState<S, A, MonitorState> & NextStateExt,\n        LiftedAction<S, A, MonitorState>\n      > &\n        NextExt & {\n          liftedStore: Store<\n            LiftedState<S, A, MonitorState>,\n            LiftedAction<S, A, MonitorState>\n          >;\n        }).liftedStore\n    ) {\n      throw new Error(\n        'DevTools instrumentation should not be applied more than once. ' +\n          'Check your store configuration.'\n      );\n    }\n\n    return unliftStore<\n      S,\n      A,\n      MonitorState,\n      MonitorAction,\n      NextExt,\n      NextStateExt\n    >(\n      liftedStore,\n      liftReducer,\n      (options as unknown) as Options<S, A, MonitorState, MonitorAction>\n    );\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}